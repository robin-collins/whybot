
## PROJECT OVERVIEW

This project aims to build a knowledge graph exploration tool using a combination of React, Cytoscape.js, and OpenAI's API.  The application allows users to input a question, explore related concepts, and generate a visual graph representation of their knowledge exploration.  The application incorporates various features such as graph persistence, export/import functionalities, and a user-friendly interface. Version 1.0.0 of the graph export format is currently implemented.


## CODE STYLE

- Adhere to standard JavaScript/TypeScript coding conventions.
- Maintain consistent indentation (2 spaces).
- Use descriptive variable and function names.
- Follow the Prettier code formatting rules defined in .prettierrc.
- Utilize ESLint for linting and code quality checks, as defined in .eslintrc.json.  The `app/eslint.config.js` file should be updated as described in 2025-04-03_06-24-identifying-project-module-types.md.  The `lint` and `lint:fix` scripts in `app/package.json` should be updated to remove the `--ext` and `--report-unused-disable-directives` flags.
- Code should be properly formatted, linted, and successfully built before execution.
- Add `lint:fix` and `format` scripts to `app/package.json` as described in 2025-04-03_06-21-adding-lint-and-format-scripts.md


## FOLDER ORGANIZATION

The project uses a structured folder organization to enhance maintainability and scalability:

- `/app`: Frontend application code.
    - `/src`: Source code.
        - `/components`: Reusable UI components (e.g., NodeGraph, QuestionNode, DataNode, NodeToolbar, EditableText, UIControls, APIKeyModal, UserQuestionNode, UserFileNode, WebPageNode, InteractiveNode).
        - `/pages`: Page-specific components (e.g., AboutPage, HomePage, GraphPage).
        - `/hooks`: Custom React hooks (e.g., useGraphPersistence).
        - `/types`: Type definitions (e.g., GraphTypes, WebSocketTypes, UserNodeType).
        - `/services`: Data fetching and interaction logic (e.g., websocket).
        - `/utils`: Utility functions (e.g., graphExport, graphImport, convertTreeToFlow).
        - `/models`: Models and their configurations.
        - `/personas`: Personas and their prompts.
        - `/store`: Zustand store files (e.g., appStore.ts)
    - `/public`: Static assets.
- `/server`: Backend server code.
    - `/routes`: API route handlers.
    - `/examples`: Example data for the application.
    - `/logs`: Directory for storing server logs.
- `/types`: Type definitions for the project.


## TECH STACK

- Frontend: React, React Router, TypeScript, Cytoscape.js, react-textarea-autosize, react-markdown, framer-motion, localforage, classnames, remark-gfm, @tailwindcss/typography, react-flow, @heroicons/react/24/solid, @headlessui/react, Puppeteer, readability, zustand, immer, react-use-measure, zustand/react/shallow
- Backend: Node.js, Express.js, Firebase, OpenAI API, ws, puppeteer, @mozilla/readability, turndown, jsdom
- Testing: (To be defined)
- Backend Added Packages: puppeteer, @mozilla/readability, turndown, @types/turndown, openai (updated to v4+), firebase-admin (updated)
- Backend Added Packages: puppeteer, @mozilla/readability, turndown, @types/turndown


## PROJECT-SPECIFIC STANDARDS

- All new components should follow the established folder structure and naming conventions.
- Error handling should be robust and informative, providing clear messages to the user.
- The application should be designed for scalability and maintainability.
- The WebSocket service should handle reconnections and provide feedback to the user on connection status.
- The graph data should be persisted locally using localStorage for session persistence.
- The graph data should be exportable in JSON, SVG, and PNG formats.
- **New Node Generation Behavior:** The automatic generation of new question nodes should stop after creating the initial two question nodes. These nodes will contain an "answer" button, which triggers the generation of the answer node only when clicked. This behavior is implemented in `app/src/GraphPage.tsx` and `app/src/FadeoutTextNode.tsx`.  The changes are documented in 2025-04-01_22-43-control-node-graph-behavior.md and 2025-04-02_09-13-modify-graph-node-answer-generation-logic.md.  Key files involved: `app/src/GraphPage.tsx`, `app/src/FadeoutTextNode.tsx`, `app/src/Flow.tsx`, `app/src/personas.ts`.
- **Answer Node Rendering:** Answer nodes now render text using `react-markdown` with `remark-gfm` support for GitHub Flavored Markdown.  Full text display is enabled for answer nodes, removing previous truncation limitations. Answer nodes have a light green border and a 3px thick border. Changes are reflected in `app/src/FadeoutTextNode.tsx` and `app/src/fadeout-text.css`.  These changes were implemented on 2025-04-02 based on user request documented in 2025-04-01_23-25-app-update-markdown-and-node-styling-enhancements.md.  Additional changes include the use of Tailwind's `prose` and `prose-sm` classes for improved Markdown styling.  This requires installing `@tailwindcss/typography` and adding it to your `tailwind.config.js`.
- **Question Node and Button Improvements:** Question nodes are now sized to prevent the "Answer" button from overlapping the question text. The button text changes to "Answering..." and turns green while the answer is being generated.  The button disappears after the answer node is created. Changes are reflected in `app/src/GraphPage.tsx` and `app/src/FadeoutTextNode.tsx`.  These changes were implemented on 2025-04-02 based on user request documented in 2025-04-01_23-42-untitled.md.  Further improvements based on 2025-04-01_23-42-enhancing-question-node-ui-and-button-behavior.md include increased padding to prevent button overlap and a visual indicator (green button, "Answering..." text) while the answer is being generated.  The button is disabled during this process.
- **Answer Node Expansion:** If the answer text exceeds 1500 characters, the node's width animates from its initial size to 150% when expanded. The height adjusts to fit the content.  This addresses issues with Markdown header rendering and improves the display of long answers.  Changes implemented in `app/src/FadeoutTextNode.tsx` and `app/src/fadeout-text.css` on 2025-04-02 based on user request documented in 2025-04-02_00-57-untitled.md.
- **Answer Node Markdown Rendering and Expansion:**  If the answer text exceeds 1500 characters, the node's width animates from its initial size (250px) to 150% (375px) when expanded. The height adjusts to fit the content. Markdown headers now render correctly with appropriate styling.  These changes were implemented in `app/src/FadeoutTextNode.tsx` on 2025-04-02 based on user request documented in 2025-04-02_00-57-enhancing-answer-node-functionality-and-markdown-rendering.md. The `prose-sm` class was removed to allow default `prose` styling for headers.  To address extra padding introduced by prose styles, ensure `@tailwindcss/typography` is installed and configured in `tailwind.config.js`. Add the `[&>*:first-child]:mt-0` class to remove top margin from the first child within the prose container in `app/src/FadeoutTextNode.tsx`.  Answer nodes should have a 3px thick border (`border-[3px]`). List markers should be styled with `prose-li:marker:text-black` and `prose-li:my-1` for improved styling. The `leading-tight` class should be used to set the line-height to 1.25em.  Additional styling `[&_ul>li:first-child]:mt-[0.25em] [&_ol>li:first-child]:mt-[0.25em]` was added to reduce top margin on the first list item of unordered and ordered lists. The addition of `[&_ul]:mt-[0.25em] [&_ol]:mt-[0.25em]` further reduced the spacing around nested lists.
- **TailwindCSS Typography Plugin:** Ensure `@tailwindcss/typography` is installed and configured in `tailwind.config.js` for proper Markdown styling and header rendering.  The `prose` class should be used for markdown rendering.  Additional styling may be required to remove excess padding.  The `[&>*:first-child]:mt-0` class can be applied to the inner `div` containing the `ReactMarkdown` component to remove top margin from the first child.  Answer nodes should have a 3px thick border (`border-[3px]`).  List markers (ordered and unordered list bullets and numbers) should be styled with `prose-li:marker:text-black` to ensure they are black.  To reduce excessive spacing around list items, use `prose-li:my-1`.  The `leading-tight` class should be used to set the line-height to 1.25em.  Additional styling `[&_ul]:mt-[0.25em] [&_ol]:mt-[0.25em]` was added to reduce top margin on nested lists.  The `[&_p]:mt-[1em] [&_p]:mb-0` classes should be used to reduce vertical spacing around paragraphs.
- **Answer Node Expansion and Child Node Positioning:** When an answer node expands due to long content, the layout algorithm should recalculate the positions of newly generated child question nodes using the expanded dimensions of the parent answer node.  This requires modification to the node placement logic within `app/src/GraphPage.tsx`.  Further investigation and debugging are needed to ensure correct placement after expansion.  This issue was identified on 2025-04-02 and documented in 2025-04-02_02-07-untitled.md.  The issue has been identified and resolved by updating the `layoutElements` function in `app/src/Flow.tsx` to use the actual width and height from the `dagre` layout engine instead of hardcoded values for offset calculations. This ensures the layout correctly reflects the expanded dimensions of the answer node. The fix is documented in 2025-04-02_02-07-node-layout-issue-with-answer-expansion.md.  Further debugging revealed that the issue persisted due to timing of state updates.  Logging was added to `layoutElements` in `app/src/Flow.tsx` to confirm that the correct dimensions were being used.  The issue remains unresolved and requires further investigation.  The problem is likely due to the timing of state updates in `FadeoutTextNode.tsx`.  The `setNodeDims` function should be called reliably whenever the node's actual size changes, not just on click. This requires modification to `FadeoutTextNode.tsx` to ensure `setNodeDims` is called within the `useEffect` hook that watches `bounds.height`, and that it accounts for the component possibly not being expanded yet when dimensions are first measured.  The final fix involved moving the `setNodeDims` call into the `useEffect` hook that watches `bounds.height` in `FadeoutTextNode.tsx` to ensure dimensions are updated reliably whenever they change.  The logic was adjusted to handle cases where the node isn't expanded yet when dimensions are first measured.  A linter error was also fixed by correctly ordering variable declarations. A small delay was added to `generateAnswerForNode` in `app/src/GraphPage.tsx` to allow time for dimension updates to propagate before adding child nodes.  This delay is implemented using `setTimeout` with a 50ms delay.
- **Answer Node Scrolling:** If the answer text exceeds a certain height after expansion, a vertical scrollbar should appear within the node to allow scrolling of the content. The maximum expanded height should be limited to 99% of the browser viewport height.
- **List Item Spacing:** To reduce excessive spacing around list items, use `prose-li:my-1`.  Additional styling `[&_ul]:mt-[0.25em] [&_ol]:mt-[0.25em]` was added to reduce top margin on nested lists.
- **Layout Optimization:** To improve the layout performance and address issues with nodes not being rendered initially, the layout function in `Flow.tsx` now filters nodes to include only those with available dimensions or the initial question nodes. This ensures that the layout only processes nodes with complete information. A small delay was added to `generateAnswerForNode` in `app/src/GraphPage.tsx` using `setTimeout` with a 50ms delay to allow time for dimension updates to propagate before adding child nodes. This helps prevent race conditions where the layout is performed before the dimensions are updated.
- **Layout Timing and Node Filtering:** A delay of 50ms was added to `generateAnswerForNode` in `app/src/GraphPage.tsx` to allow time for dimension updates to propagate to `nodeDims` before adding child nodes, but this proved insufficient.  The layout function in `app/src/Flow.tsx` was updated to filter nodes, including only those with available dimensions in `nodeDims` or the initial question nodes (`q-0`).  The filter was further refined to always include the initial nodes (`q-0`, `a-0`) regardless of dimension availability.  This ensures that the initial answer node is always rendered.  This change prevents the layout from running before dimensions are available, ensuring the correct dimensions are used in the layout calculations.  The change is documented in `2025-04-02_16-28-19.md`.
- **Awaiting Dimension Updates:** To reliably ensure the layout uses updated dimensions, a small delay (`setTimeout`) was added within `generateAnswerForNode` in `app/src/GraphPage.tsx`. This delay gives React time to process the dimension updates from `app/src/FadeoutTextNode.tsx` before the layout calculation runs.  This approach was ultimately replaced by removing the filtering logic in `Flow.tsx` and allowing the layout to run on all nodes, relying on the layout function to handle missing dimensions gracefully.  This ensures that initial and subsequent nodes are rendered as intended.
- **Stricter Layout Filtering:** To address the issue of subsequent answer nodes not rendering, a stricter filtering approach was implemented in `Flow.tsx`.  Only the initial question node (`q-0`), the initial answer node (`a-0`), and any other node with dimensions available in `props.nodeDims` are included in the layout calculation. This ensures that the layout is performed only when dimensions are available, preventing incorrect node positioning.
- **Awaiting Dimension Updates:** To reliably ensure the layout uses updated dimensions, a small delay (`setTimeout`) was added within `generateAnswerForNode` in `app/src/GraphPage.tsx`. This delay gives React time to process the dimension updates from `app/src/FadeoutTextNode.tsx` before the layout calculation runs.  This approach was ultimately replaced by removing the filtering logic in `Flow.tsx` and allowing the layout to run on all nodes, relying on the layout function to handle missing dimensions gracefully.  This ensures that initial and subsequent nodes are rendered as intended.
- **Layout Function and Dimension Handling:** The layout function (`layoutElements` in `Flow.tsx`) now handles cases where node dimensions are not immediately available in `props.nodeDims`.  If dimensions are missing, the layout uses default dimensions (250x170) for those nodes. Once dimensions become available, the layout is recalculated.
- **Awaiting Dimension Updates (Final Solution):**  The issue with subsequent answer nodes not rendering correctly was ultimately resolved by using a refined filtering strategy in `Flow.tsx`. The layout function now only considers nodes for which dimensions are available in `props.nodeDims`, except for the initial question node (`q-0`) and the initial answer node (`a-0`), which are always included.  This ensures that nodes are only laid out once their dimensions are known, preventing incorrect positioning.  This solution avoids the need for artificial delays and ensures that the layout is performed correctly and efficiently.
- **Canvas Controls:** The `Flow.tsx` component has been updated to include canvas controls such as centering on the first/last node, zoom in/out, and reset zoom functionality. This involved integrating the `Controls`, `MiniMap`, and `Background` components from `react-flow` and adding custom buttons for centering on the first and last nodes, zooming in/out, and resetting the zoom.  This enhancement is based on the user request documented in 2025-04-02_07-32-enhancing-node-graph-canvas-controls.md.  The styling of the control buttons needs improvement for better readability.  A horizontal layout with icons and a zoom slider is also requested.  The styling of the control buttons has been improved for better readability. A horizontal layout with icons and a zoom slider has been implemented.  The gradient overlay on question nodes should be adjusted to be transparent until the bottom of the question text, then gradient to opaque.
- **Node Link Severing:** Implement functionality to sever a node linking line when hovering over it with a "scissors" cursor. Severing the link should delete all downstream nodes connected to that link.  This requires adding event handling to detect hover events on links and implementing the logic to remove nodes and edges.  This feature is requested in 2025-04-02_08-13-untitled.md.  This feature will require implementing a confirmation modal using `@headlessui/react`, modifying `DeletableEdge.tsx` to handle hover and click events, and adding recursive deletion logic in `GraphPage.tsx`.
- **Cascade Delete:** Implement a cascade delete feature triggered by hovering over a link with a "scissors" cursor.  Severing the link deletes all downstream nodes. This requires a confirmation modal (`@headlessui/react`), modifications to `DeletableEdge.tsx` for hover/click events, and recursive deletion logic in `GraphPage.tsx`.  This addresses the user request in 2025-04-02_08-13-implementing-cascade-delete-feature-in-graph.md.
- **User Node Types:** Three new user node types have been defined:
    - **User-Entered Question Node:** Allows users to input their own questions, mirroring the functionality of LLM-generated question nodes.  The "Answer" button is initially disabled and activates only after 20 or more characters are entered.
    - **User-Submitted File Node:** Enables users to upload text files (any extension, content must be text). The file content is displayed using Markdown formatting and included in the LLM prompt.  Requires a downstream user-entered question or web page node to ensure continued interaction.
    - **Web Page Content Node:** Allows users to input a URL.  Upon successful retrieval (HTTP 200), Puppeteer and Readability are used to extract and display the page content in Markdown format.  This content is included in the LLM prompt, and requires a downstream user-entered question or file node to ensure continued interaction.
- **Interactive Node Component:** A new universal node component (`InteractiveNode.tsx`) will be created to handle the rendering and logic for all user node types (User-Entered Question Node, User-Submitted File Node, Web Page Content Node).  This component will be integrated into the React Flow setup, and will handle file uploads, web page content fetching, and LLM prompt generation.  Backend API endpoints and data model updates (`QATreeNode`) will be required to support these new node types.
- Backend API endpoints added: `/api/fetch-webpage`
- **LLM Prompt Context:** The LLM prompt generation logic now includes context from ancestor `user-file` and `user-webpage` nodes to enrich the generated answers.  This enhancement improves the relevance and accuracy of the LLM's responses by providing additional context from user-provided files and web pages.
- **Firebase Credential Handling:** To resolve the "Getting metadata from plugin failed with error: error:1E08010C:DECODER routines::unsupported" error, the Firebase initialization in `server/server.ts` now uses `credential.applicationDefault()`. This method automatically detects credentials from the `GOOGLE_APPLICATION_CREDENTIALS` environment variable, which should point to your Firebase service account key JSON file.  Ensure this environment variable is set correctly.  A log statement has been added to verify if `GOOGLE_APPLICATION_CREDENTIALS` is set.  The service account key file should be downloaded from the Firebase console and stored securely outside of the git repository. The `GOOGLE_APPLICATION_CREDENTIALS` environment variable should be set to the path of the service account key file.  A Firestore database must be created in the Firebase console. The Firestore API must be enabled in the Google Cloud Console.  The service account must have the necessary permissions to access the Firestore database.
- **OpenAI API Call Handling:**  The JSON input supplied to `openai.chat.completions.create()` should be stored in a variable called `oai_request_json`. The reconstructed resultant stream should be stored in a variable called `oai_response_json`.
- **WebSocket Message Handling:** To resolve issues with concurrent WebSocket requests and garbled messages, the server-side WebSocket message handler in `server/server.ts` has been modified to send JSON messages including a `nodeId` to identify the request.  The client-side code in `app/src/GraphPage.tsx` (specifically within the `onChunk` callback of the `openai` function) has been updated to parse these JSON messages and update the correct node's answer content based on the `nodeId`.  The server now sends JSON messages with `type` fields ('chunk', 'done', 'error') to signal message status.  The client handles these types accordingly.
- **WebSocket Communication Protocol (WCP) Update:**  A new WebSocket communication protocol has been implemented to address issues with concurrent requests and message garbling. The server now sends JSON messages containing a `nodeId` to identify the request, and the `type` of message (`chunk`, `done`, `error`). The client-side code parses these messages and updates the correct node's answer content based on the `nodeId`.  Further investigation is needed to address reported issues where the "Answer" button does not trigger the expected behavior.  The WebSocket Communication Protocol (WCP) has been updated to include a `nodeId` in the initial request and subsequent response chunks.  The client-side code now parses these JSON messages and updates the correct node's content based on the `nodeId`.  However, there are still reported issues where the "Answer" button does not trigger the expected behavior, indicating a potential problem in how the WebSocket messages are handled on the client-side after the protocol update.  The initial seed question (`nodeId` '0') should generate its answer automatically, but now it requires a manual click, and even that doesn't work visually.  This points to a breakdown in how the WebSocket messages are sent or handled after the protocol change. The `openai` utility function (which likely manages the WebSocket connection) needs to send the initial request to the server, including the `nodeId`. The client-side `onChunk` handler needs to correctly parse the structured JSON messages and route the content based on the `nodeId`.  The logic that automatically triggered the answer for node '0' might be failing because the WebSocket communication isn't completing correctly.  The `openai` function in `app/src/Flow.tsx` has been updated to accept and send the `nodeId`.  The calls to `openai` in `app/src/GraphPage.tsx` have been updated to pass the correct `nodeId`.  A fix was implemented to prevent the re-initialization of state and generator logic if node '0' processing has already been initiated.  This involved adding a check in the `useEffect` hook in `app/src/GraphPage.tsx` to verify if `qaTreeRef.current['0']?.startedProcessing` is true before initializing the state and queue for node '0'.  This addresses the issue of duplicate requests for the initial seed question in Strict Mode.
- **MultiNodeGenerator and NodeGeneratorOpts Updates:** The `MultiNodeGenerator` now includes a `processingNodes` set to track nodes currently being processed, preventing duplicate processing of the same node. The `NodeGeneratorOpts` type has been updated to include `processingNodes`. The `nodeGenerator` function now uses this set to claim and release node IDs, avoiding race conditions.
- **TypeScript Configuration:** The `tsconfig.json` file has been updated to resolve TypeScript compiler errors.  The `"moduleResolution"` setting has been changed from `"bundler"` to `"node"`, `"allowImportingTsExtensions"` has been removed (as it's an unsupported option), and `"resolveJsonModule"` is retained as it's now compatible with the `"node"` module resolution.  The `"allowSyntheticDefaultImports"` setting has been added to resolve errors related to synthetic default imports for libraries like React and classnames.  The `"esModuleInterop"` setting has been added for better compatibility.  The `"noUnusedLocals"`, `"noUnusedParameters"`, and `"noImplicitAny"` settings have been set to `false` to reduce the number of errors while focusing on core functionality.  An empty `export {}` statement has been added to `app/src/util/fileUtils.ts` to make it a proper module.  The import statement in `app/src/main.tsx` has been updated to remove the `.tsx` extension from the import of `App`.
- **TypeScript Configuration Update (2025-04-03):** The `tsconfig.json` file has been further updated to resolve remaining TypeScript compiler errors. Specifically, `"allowSyntheticDefaultImports": true` has been added to allow importing modules without default exports. This addresses errors related to synthetic default imports for libraries like React and classnames.
- **TypeScript Configuration Update (2025-04-03):**  The `tsconfig.json` file has been updated to resolve TypeScript compiler errors. The `"moduleResolution"` setting has been changed to `"node"`, `"allowImportingTsExtensions"` has been removed, and `"resolveJsonModule"` is retained.  The `"allowSyntheticDefaultImports"` setting has been added. The `"esModuleInterop"` setting has been added. The `"noUnusedLocals"`, `"noUnusedParameters"`, and `"noImplicitAny"` settings have been set to `false`. An empty `export {}` statement has been added to `app/src/util/fileUtils.ts`. The import statement in `app/src/main.tsx` has been updated.  Additionally, an empty `export {}` statement has been added to `app/src/util/urlUtils.ts` to address a `TS1208` error.  Error handling has been added to `app/src/GraphPage.tsx` to handle cases where `opts.qaTreeRef.current` or `nodeId` are null or undefined before accessing properties, thus resolving `TS2538` errors.
- **tsconfig.json Update:**  The `"moduleResolution"` setting should be `"node"`, `"allowSyntheticDefaultImports"` should be `true`, and `"esModuleInterop"` should be `true`.  Add error handling to prevent accessing undefined properties (like `opts.qaTreeRef.current[nodeId]`). Add empty `export {}` statements to files that need to be treated as modules to avoid `TS1208` errors. Correct import paths to avoid `TS2614` errors. Ensure that functions correctly resolve promises to avoid type mismatches in function calls. Add a new `/types` directory to the project structure and create `GraphTypes.ts` and `Examples.ts` files within it to define the necessary types. Add a `convertTreeToFlow.ts` file to the `/util` directory.
- **State Management Refactoring:** Refactor state management to use Zustand for improved clarity and efficiency.  This will involve consolidating shared application state into a single Zustand store (`useAppStore`), using `immer` for immutable updates, and `devtools` for debugging.  The current `useRef`/`useState` combination in `app/src/GraphPage.tsx` and other scattered state logic will be replaced.  Files likely needing refactoring include `app/src/GraphPage.tsx`, `app/src/Flow.tsx`, `app/src/InteractiveNode.tsx`, `app/src/FadeoutTextNode.tsx`, `app/src/APIKeyModal.tsx`, `app/src/AddNodeModal.tsx`, `app/src/StartPage.tsx`, and `app/src/App.tsx`.  Thorough documentation and inline commenting will be added to improve code understanding.  Unused or placeholder code will be identified and marked with TODO comments.  A revised plan for implementing Zustand state management is detailed in `zustand_update.md`. This plan addresses the need for simpler state management, improved documentation and commenting, and handling of errors.  The plan also outlines the steps for refactoring specific components to use the Zustand store, including integrating the generator logic, handling API key persistence, and implementing error handling.  The plan has been updated to address the omissions and errors identified in the report, including the recursive `deleteNode` implementation, proper store initialization using an `initializeTree` action, consistent API key handling with persistence in the store action, error state management, refined generator trigger logic, accurate `reactFlowNodesFromQaTree` and `reactFlowEdgesFromQaTree` helper functions, reintegration of API key validation, and addressing potential rendering issues with the
- **Zustand Store Implementation:** The Zustand store has been implemented in `app/src/store/appStore.ts`.  The store includes state for the QA tree, playing status, focused node ID, API key, model, persona, generation status, and error messages.  Actions are provided for initializing the tree, setting the playing status, setting the focused node ID, setting the API key, setting the model, setting the persona, setting the generation status, setting error messages, setting the initial tree, adding a node, updating a node, deleting a node and its descendants, and updating a node's answer chunk. Selectors are provided for accessing the QA tree, checking if the tree is initialized, getting the playing status, getting the focused node ID, getting the API key, getting the error message, getting the generation status, getting the model, and getting the persona.  The store uses the `immer` middleware for immutable updates, the `devtools` middleware for debugging, and the `persist` middleware for persisting the API key, model, and persona to local storage.  The store includes a helper function for getting all descendant IDs of a node.  The store includes error handling for adding duplicate nodes and updating non-existent nodes.  The store includes error handling for streaming to non-existent nodes.  The store includes error handling for deleting non-existent nodes.  The store includes a helper function for getting all descendant IDs of a node.  The store includes error handling for adding duplicate nodes and updating non-existent nodes.  The store includes error handling for streaming to non-existent nodes.  The store includes error handling for deleting non-existent nodes.
- **Module Type:** The project uses JavaScript modules (import/export), as indicated by `"type": "module"` in `package.json`.
- **Framework:** The project uses React, as indicated by the presence of `"react"` and `"react-dom"` in `app/package.json`.
- The application runs in both the browser and Node.js environments.
- **Error Handling:** Implement a custom error boundary component to handle the "Maximum update depth exceeded" error. This will involve creating a new component that catches errors and renders a user-friendly message instead of the default React error message.  This addresses the error reported in 2025-04-03_07-03-untitled.md.
- **Zustand `useShallow` Hook:** To address the "Maximum update depth exceeded" error, the `useShallow` hook from `zustand/react/shallow` should be used when selecting multiple state slices and actions from the Zustand store. This prevents unnecessary re-renders caused by returning a new object reference on every render. This addresses the issue identified in `2025-04-03_07-03-debugging-react-maximum-update-depth-error.md` and updates the `InteractiveNode.tsx` component.
- **API Key Persistence and GraphPage Initialization:** To resolve the issue where the API key is not correctly retrieved in `GraphPage`, ensure that the `persist` middleware in the Zustand store is correctly configured and that the store is fully rehydrated before `generateAnswerForNode` is called.  Add logging statements to track the API key value at various points in the application lifecycle to pinpoint the exact location of the problem.  Investigate potential timing issues where the API key might not be available when `generateAnswerForNode` is first called.  Consider adding error handling to gracefully manage cases where the API key is not found. The API key is now handled server-side; client-side API key handling has been removed.  The `persist` middleware in the Zustand store is correctly configured and the store is fully rehydrated before `generateAnswerForNode` is called.  The API key is handled server-side, so client-side API key handling has been removed.
- **Error Handling for Node Graph:** Implement comprehensive error handling to catch and display informative error messages to the user, especially during node processing.  Address the error: `Error: Error processing node q-0: Could not get answer prompt for node q-0 with persona undefined`. This requires checking for undefined personas before attempting to generate prompts.
- **Persona State Management:** To resolve the "persona undefined" error, refactor `App.tsx` and `StartPage.tsx` to use the Zustand store as the single source of truth for the `model` and `persona` state.  `App.tsx` will only manage navigation state, while `StartPage.tsx` will directly interact with the Zustand store to update `model` and `persona` when the user makes selections.  This ensures that the `GraphPage` component has access to the correct `persona` when it initializes.  The refactored `App.tsx` and `StartPage.tsx` components are included in 2025-04-03_08-33-node-graph-error-and-state-management-fix.md.  No further changes are needed in `GraphPage.tsx` as it already correctly reads the `persona` from the Zustand store.
- **Generator Loop and Answer Node Creation:** The `generatorLoop` function in `GraphPage.tsx` needs to be refactored to explicitly create the answer node (`a-0`) in the `qaTree` state before starting the OpenAI stream. The `onChunk` callback should then update the answer content on this dedicated answer node, rather than appending to the question node. The `convertTreeToFlow` function should be modified to remove the implicit creation of the answer node, as it will now be explicitly managed in the `qaTree` state.
- **Automatic Node Generation Removed:** The automatic generation of answer and question nodes has been removed.  All node generation is now user-driven through explicit button clicks.


## WORKFLOW & RELEASE RULES

 - Follow the standard Gitflow branching model.
 - Create detailed commit messages explaining the changes.
 - Before pushing code, ensure all tests pass.
 - Code reviews are mandatory for all pull requests.
 - Release process: (To be defined)
 - Use a monorepo structure with workspaces defined in the root `package.json` to manage the `/app` and `/server` packages.  The root `package.json` should include a `workspaces` array specifying these directories.


## REFERENCE EXAMPLES

 - Example graph data structures are stored in `/server/examples`.
 - Reference examples for various components and functionalities can be added here.


## PROJECT DOCUMENTATION & CONTEXT SYSTEM

 - Project documentation is maintained using Markdown files.
 - The main project plan is located in `PLAN.md`.
 - Detailed documentation is maintained for each component and function.
 - Version 1.0.0 of the graph export format is currently in use.
 - Backend API endpoints added: `/api/fetch-webpage`


## DEBUGGING

 - Use the browser's developer tools to debug frontend issues.
 - Use verbose logging in the backend server