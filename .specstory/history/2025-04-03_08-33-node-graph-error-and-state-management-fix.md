<!-- Generated by SpecStory -->

# Node Graph Error and State Management Fix (2025-04-03 19:03:54)

_**User**_

sent question. node graph page loaded, first question node present. error msg at top of screen. `Error: Error processing node q-0: Could not get answer prompt for node q-0 with persona undefined`
The browsers console logs are @browser_console.log 




---

_**Assistant**_

Okay, I understand the issue. The error `Could not get answer prompt for node q-0 with persona undefined` arises because the `persona` state within the Zustand store (`appStore.ts`) is `null` or `undefined` when the `GraphPage` component initializes and its `generatorLoop` attempts to generate the first answer.

The `persona` selected on the `StartPage` is currently managed by local state in `App.tsx` and isn't being correctly propagated to the Zustand store before `GraphPage` needs it.

To fix this, we need to ensure that the `model` and `persona` selected on the `StartPage` are set in the Zustand store *before* navigating to the `GraphPage`. The most robust way is to make Zustand the single source of truth for this state.

Here's the plan:

1.  **Refactor `App.tsx`:** Remove the local state management for `model` and `persona`. It will only manage the `seedQuery` and `example` state to control navigation.
2.  **Refactor `StartPage.tsx`:** Update it to read `model` and `persona` directly from the Zustand store and use store actions to update them when the user changes selections in the dropdowns.
3.  **Update `GraphPage.tsx` initialization:** Ensure `GraphPage` uses the `persona` already present in the store when it initializes the tree. The current code already does this, so no change should be needed there, provided the store is updated correctly beforehand.

Let's start by refactoring `App.tsx`. I will remove the local state for `model` and `persona` and simplify the props passed to `StartPage`.

```typescript
import { useState } from "react";
import "./index.css";
import GraphPage from "./GraphPage";
import { GraphPageExample } from "./GraphPageExample";
import StartPage, { Example } from "./StartPage";
import { RouterProvider, createBrowserRouter } from "react-router-dom";
import AboutPage from "./AboutPage";
// Removed imports for MODELS, PERSONAS as they are managed via store/StartPage now
// Removed import for useAppStore here, StartPage will handle store interaction

function CoreStuff() {
  const [seedQuery, setSeedQuery] = useState<string>();
  const [example, setExample] = useState<Example>();

  // Removed local model and persona state

  return example ? (
    <div className="text-white bg-zinc-700 h-screen w-screen fixed left-0 top-0">
      <GraphPageExample
        example={example}
        onExit={() => {
          // Clear both seedQuery and example on exit
          setSeedQuery(undefined);
          setExample(undefined);
        }}
      />
    </div>
  ) : seedQuery ? (
    <div className="text-white bg-zinc-700 h-screen w-screen fixed left-0 top-0">
      <GraphPage
        onExit={() => setSeedQuery(undefined)} // Clears seedQuery to return to StartPage
        seedQuery={seedQuery}
        // Removed model and persona props
      />
    </div>
  ) : (
    <div className="text-white bg-zinc-700 min-h-screen flex flex-col">
      <StartPage
        // Removed model, persona, onSetModel, onSetPersona props
        onSetExample={setExample}
        onSubmitPrompt={(query) => {
          setSeedQuery(query); // Only set seedQuery to navigate
        }}
      />
    </div>
  );
}

const router = createBrowserRouter([
  {
    path: "/",
    element: <CoreStuff />,
  },
  {
    path: "/about",
    element: <AboutPage />,
  },
]);

function App() {
  return <RouterProvider router={router} />;
}

export default App;
```

Now I will refactor `StartPage.tsx` to interact directly with the Zustand store.

```typescript
import { useState, Dispatch, SetStateAction, useEffect, useMemo } from "react";
import "./index.css";
import {
  PaperAirplaneIcon,
  InformationCircleIcon,
} from "@heroicons/react/24/outline";
import classNames from "classnames";
import TextareaAutosize from "react-textarea-autosize";
import { QATree } from "./types";
import { PERSONAS } from "./personas"; // Keep PERSONAS for dropdown and random question prompt
import { useQuery } from "@tanstack/react-query";
import { getFingerprint } from "./main";
import { SERVER_HOST } from "./constants";
import { MODELS } from "./models"; // Keep MODELS for dropdown
import Dropdown from "./Dropdown";
import { PlayCircleIcon } from "@heroicons/react/24/outline";
import { APIInfoModal, APIKeyModal } from "./APIKeyModal";
import { Link } from "react-router-dom";
import { collection, addDoc } from "firebase/firestore";
import { db } from "./firebase";
import { Sidebar } from "./CollapsibleSidebar";
import { useAppStore } from "./store/appStore"; // Import the store
import { useShallow } from "zustand/react/shallow"; // Import useShallow for multiple selections

export type Example = {
  persona: string;
  model: string;
  tree: QATree;
};

// Removed props: model, persona, onSetModel, onSetPersona
function StartPage(props: {
  onSubmitPrompt: (prompt: string) => void;
  onSetExample: (example: Example) => void;
}) {
  // Get state and actions from Zustand store
  const { model, persona, setModel, setPersona } = useAppStore(
    useShallow((state) => ({
      model: state.model,
      persona: state.persona, // Store now holds the Persona object or null
      setModel: state.setModel,
      setPersona: state.setPersona,
    }))
  );

  // Initialize persona in store if it's null on first load
  useEffect(() => {
    if (persona === null) {
      const defaultPersonaKey = Object.keys(PERSONAS)[0];
      setPersona(PERSONAS[defaultPersonaKey]);
      console.log("StartPage: Initialized persona in store to default:", defaultPersonaKey);
    }
  }, [persona, setPersona]);


  const [query, setQuery] = useState("");
  const [isInfoModalOpen, setIsInfoModalOpen] = useState(false);
  const [isApiKeyModalOpen, setIsApiKeyModalOpen] = useState(false);
  const [isSidebarOpen, setSidebarOpen] = useState(false);

  const promptsRemainingQuery = useQuery({
    // Use model from store in queryKey
    queryKey: ["promptsRemaining", model],
    queryFn: async () => {
      const result = await fetch(
        // Use model from store in API call
        `${SERVER_HOST}/api/prompts-remaining?model=${model}&fp=${await getFingerprint()}`
      );
      return result.json();
    },
  });

  const promptsRemaining = useMemo(() => {
    if (promptsRemainingQuery.isLoading) return "...";
    if (promptsRemainingQuery.error) return "?!";
    return promptsRemainingQuery.data?.remaining ?? "?";
  }, [promptsRemainingQuery.isLoading, promptsRemainingQuery.error, promptsRemainingQuery.data]);

  const disableEverything = promptsRemaining === 0;

  const examplesQuery = useQuery({
    queryKey: ["examples"],
    queryFn: async () => {
      const result = await fetch(`${SERVER_HOST}/api/examples`);
      return result.json();
    },
  });
  const examples: Example[] = examplesQuery.isLoading ? [] : examplesQuery.data ?? [];

  async function submitPrompt() {
    // Ensure persona is selected before submitting
     if (!persona) {
      console.error("Cannot submit prompt: Persona is not selected in the store.");
      // Optionally show an error message to the user
      return;
    }
    props.onSubmitPrompt(query);
    // Use model from store
    fetch(
      `${SERVER_HOST}/api/use-prompt?model=${model}&fp=${await getFingerprint()}`
    );

    try {
      const docRef = await addDoc(collection(db, "prompts"), {
        userId: await getFingerprint(),
        model: model, // Use model from store
        persona: persona.name, // Use persona name from store
        prompt: query,
        createdAt: new Date(),
        href: window.location.href,
        usingPersonalApiKey: false, // Assuming this is handled elsewhere if needed
      });
      console.log("Document written with ID: ", docRef.id);
    } catch (e) {
      console.error("Error adding document: ", e);
    }
  }

  const [randomQuestionLoading, setRandomQuestionLoading] = useState(false);

  // Handle case where persona might be null initially
  const currentPersonaKey = useMemo(() => persona?.name ?? Object.keys(PERSONAS)[0], [persona]);
  const currentPersonaObject = useMemo(() => persona ?? PERSONAS[Object.keys(PERSONAS)[0]], [persona]);


  return (
    <>
      <div className="m-4">
        <div className="flex justify-end items-center gap-4 mr-8 space-x-4">
          <Sidebar
            toggleSidebar={() => {
              setSidebarOpen(!isSidebarOpen);
            }}
            isOpen={isSidebarOpen}
            persona={currentPersonaKey} // Pass the key for the dropdown
            // Pass the actual setPersona action, expecting a key
            onSetPersona={(key) => setPersona(PERSONAS[key])}
            model={model} // Pass model key
            onSetModel={setModel} // Pass setModel action
          />
           {/* Rest of the header remains the same */}
          <div className="flex items-center gap-4 flex-wrap">
            <div
              className="flex items-center space-x-1 cursor-pointer opacity-80 hover:text-gray-100"
              onClick={() => setIsInfoModalOpen(true)} // Re-added onClick
            >
              <div
                className={classNames(
                  "border-b border-dashed border-gray-300 text-sm text-gray-300 shrink-0",
                  {
                    "text-white rounded px-2 py-1 border-none bg-red-700 hover:bg-red-800":
                      disableEverything,
                  }
                )}
              >
                {promptsRemaining} prompt{promptsRemaining === 1 ? "" : "s"} left
              </div>
              <InformationCircleIcon className="h-5 w-5 text-gray-400" />
            </div>
          </div>
          <div>
            <Link
              className="text-sm text-white/70 mt-1 hover:text-white/80"
              to="/about"
            >
              About
            </Link>
          </div>
        </div>
        <APIInfoModal
          open={isInfoModalOpen}
          onClose={() => {
            setIsInfoModalOpen(false);
          }}
          setApiKeyModalOpen={() => {
            setIsApiKeyModalOpen(true);
          }}
        />
        <APIKeyModal
          open={isApiKeyModalOpen}
          onClose={() => {
            setIsApiKeyModalOpen(false);
          }}
        />
      </div>
      <div className="w-[450px] max-w-full mx-auto flex flex-col mt-40 px-4 fs-unmask">
        <div
          className={classNames("fs-unmask", {
            "opacity-30 cursor-not-allowed": disableEverything,
          })}
        >
          <div
            className={classNames("fs-unmask", {
              "pointer-events-none": disableEverything,
            })}
          >
            <div className="mb-4 fs-unmask">
              What would you like to understand?
            </div>
            <div className="flex space-x-2 items-center mb-4 fs-unmask">
              <TextareaAutosize
                disabled={disableEverything}
                className="fs-unmask w-[400px] text-2xl outline-none bg-transparent border-b border-white/40 focus:border-white overflow-hidden shrink"
                placeholder="Why..."
                value={query}
                onChange={(e) => {
                  setQuery(e.target.value);
                }}
                onKeyDown={(e) => {
                  if (e.key === "Enter" && !disableEverything && query) {
                    submitPrompt();
                  }
                }}
              />
              <PaperAirplaneIcon
                className={classNames("w-5 h-5 shrink-0", {
                  "opacity-30": !query || disableEverything,
                  "cursor-pointer hover:text-white/80": query && !disableEverything,
                })}
                onClick={async () => {
                  if (query && !disableEverything) {
                    submitPrompt();
                  }
                }}
              />
            </div>
            <div className={classNames("flex space-x-4 items-center group", {
                "cursor-pointer": !disableEverything,
                "cursor-not-allowed": disableEverything,
            })}>
              <img
                src="https://cdn-icons-png.flaticon.com/512/3004/3004157.png"
                className={classNames(
                  "w-6 h-6 invert opacity-70 group-hover:opacity-80",
                  {
                    "animate-pulse": randomQuestionLoading,
                  }
                )}
                alt="Suggest random question icon" // Added alt text
              />
              <div
                className={classNames("text-sm opacity-70", {
                    "group-hover:opacity-80": !disableEverything,
                })}
                onClick={async () => {
                  if (disableEverything) return;
                  setQuery("");
                  setRandomQuestionLoading(true);
                  try {
                       // Use currentPersonaObject which is guaranteed to be a Persona
                      await window.openai(
                        currentPersonaObject.promptForRandomQuestion,
                        {
                          model: "gpt-4o-mini", // Maybe use selected model? Hardcoding for now.
                          temperature: 1,
                          nodeId: "random-question-node",
                          onChunk: (chunk) => {
                            try {
                              const parsed = JSON.parse(chunk);
                              if (parsed.type === "chunk" && parsed.content) {
                                setQuery((old) => old + parsed.content);
                              }
                            } catch (e) {
                              console.error(
                                "Error parsing random question chunk:",
                                chunk,
                                e
                              );
                            }
                          },
                        }
                      );
                  } catch (error) {
                      console.error("Failed to get random question:", error);
                      // Optionally set an error state for the user
                  }
                  setRandomQuestionLoading(false);
                }}
              >
                Suggest random question
              </div>
            </div>
          </div>
        </div>
        <div className="mt-32 text-gray-300 mb-16">
          <div className="mb-4">Play example runs</div>
          {examples
             // Filter examples based on the currently selected persona's name
            .filter((ex) => ex.persona === currentPersonaKey)
            .map((example, i) => {
              return (
                <div
                  key={i}
                  className="mb-4 flex items-center space-x-2 text-white/50 hover:border-gray-300 hover:text-gray-300 cursor-pointer"
                  onClick={() => {
                     // Set the example state in App.tsx
                    props.onSetExample(example);
                  }}
                >
                  <PlayCircleIcon className="w-5 h-5 shrink-0" />
                  {/* Use example.tree["0"] assuming it's the root */}
                  <div>{example.tree["q-0"]?.question || example.tree["0"]?.question || "Example"}</div>
                </div>
              );
            })}
        </div>
      </div>
      {/* Backdoor remains the same */}
      <div
        id="backdoor"
        className="left-0 bottom-0 w-6 h-6 fixed"
        onClick={async () => {
          try {
            const docRef = await addDoc(collection(db, "backdoorHits"), {
              userId: await getFingerprint(),
              model: model, // Use model from store
              persona: currentPersonaKey, // Use persona name from store
              prompt: query,
              createdAt: new Date(),
              href: window.location.href,
              usingPersonalApiKey: false, // Placeholder
            });
            console.log("Document written with ID: ", docRef.id);
          } catch (e) {
            console.error("Error adding document: ", e);
          }
          fetch(
            `${SERVER_HOST}/api/moar-prompts?model=${model}&fp=${await getFingerprint()}`
          );
        }}
      />
    </>
  );
}

export default StartPage;
```

With these changes, `StartPage` now directly reads and updates the `model` and `persona` in the Zustand store. When the user clicks submit, `App.tsx` only needs to set the `seedQuery`, and the `GraphPage` will initialize using the `model` and `persona` already correctly set in the store via `StartPage`'s interactions.

This should resolve the "persona undefined" error. Please try running the application again.

---

_**User**_

now to udate GraphPage.tsx initialization: Ensure GraphPage uses the persona already present in the store when it initializes the tree. The current code already does this, so no change should be needed there, provided the store is updated correctly beforehand.

---

_**Assistant**_

You are correct. Based on the previous analysis, the core issue was that the `persona` wasn't being set *in the store* before `GraphPage` was mounted and tried to use it.

Let's quickly verify the relevant parts of `GraphPage.tsx` to confirm it reads from the store:

1.  **State Selection:**
    ```typescript
    const {
      // ... other state ...
      persona,
      // ... other state ...
    } = useAppStore(
      useShallow((state) => ({
        // ... other state selections ...
        persona: state.persona, // Reads persona from store
        // ... other state selections ...
      }))
    );
    ```
    This correctly uses `useAppStore` with `useShallow` to get the `persona` object from the store.

2.  **Tree Initialization:**
    ```typescript
    useEffect(() => {
      if (!isTreeInitialized && props.seedQuery) {
        console.log("GraphPage: Initializing tree in Zustand store.");
        // initializeTree doesn't directly use the persona here,
        // but it sets up the initial state.
        initializeTree(props.seedQuery);
      }
    }, [isTreeInitialized, initializeTree, props.seedQuery]);
    ```
    The `initializeTree` action itself doesn't require the persona at the moment it's called.

3.  **Prompt Generation (inside `generatorLoop` and `generateAnswerForNode`):**
    ```typescript
    // Inside generatorLoop (simplified)
    const currentState = useAppStore.getState();
    // ...
    const promptForAnswer = currentState.persona?.getPromptForAnswer(
      node,
      currentTree
    );
    if (!promptForAnswer || !currentState.persona) { // Checks if persona exists
        throw new Error(
          `Could not get answer prompt for node ${nodeIdToProcess} with persona ${currentState.persona?.name}`
        );
    }
    // ... uses currentState.model and currentState.persona

    // Inside generateAnswerForNode (simplified)
    const {
        // ...
        persona,
        // ...
      } = useAppStore.getState();
      // ...
      if (!persona) { // Checks if persona exists
          console.error("generateAnswerForNode: No persona selected");
          // ... sets error, returns ...
          return;
      }
      // ... uses persona.getPromptForAnswer ...
    ```
    Both the automatic generator loop and the manually triggered `generateAnswerForNode` function correctly access the `persona` directly from the latest store state (`useAppStore.getState()`) and include checks to ensure it's not null/undefined before proceeding.

**Conclusion:**

Yes, `GraphPage.tsx` is already set up to read the `persona` directly from the Zustand store when it needs it for generating prompts. The changes made previously in `App.tsx` and `StartPage.tsx` ensure that the store *has* the correct `persona` selected *before* `GraphPage` attempts to use it.

Therefore, **no changes are required in `GraphPage.tsx`** regarding how it accesses the persona state. The error should now be resolved.

---

_**User**_

graph page loaded, still no answer node, only question. it definately sent the question, as the server got an OpenAI stream. I dont understand why this is so hard. You ask the question on the start page, hit submit, the node graph loads with the question node ready to go, the question is already sent to the server, graph reads websocket for openai stream. As soon as the stream starts to come in (in chunks) the answer node is placed (small), it then grows as the stream floods in. if it gets large enough it expands the width, if it still get large enough, it stops growing the node at 99% viewport windows size, and you scroll the content. Once answser is fully streamed, it generates two questions, creates two question nodes, linked to the prior answer node. ready for the user to hit the answer button.

The automatic generation flow is not needed or wanted, it should all be user driven.

---

_**Assistant**_

Okay, I understand the frustration. It seems the core issue is the transition from the initial question submission to the appearance and population of the first answer node (`a-0`) on the `GraphPage`. The automatic generation flow is indeed interfering with the expected user-driven behavior.

Let's fix this by:

1.  **Removing the Automatic Generator:** We'll completely remove the `generatorLoop` `useEffect` in `GraphPage.tsx` as you requested.
2.  **Triggering the First Answer:** We'll add logic to `GraphPage.tsx` to automatically call `generateAnswerForNode` specifically for the initial node (`q-0`) right after the graph page loads and the initial tree is set up.
3.  **Refining Answer Node Creation:** We'll slightly adjust how the answer node's data is created in `convertTreeToFlow` for clarity and to prevent potential issues from spreading the question node's data.
4.  **Adding Logs:** We'll add console logs to trace the creation and population of the answer node.

Here are the proposed changes for `app/src/GraphPage.tsx`:

```typescript
import React, {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import { Flow } from "./Flow";
import { Edge, MarkerType, Node } from "reactflow";
import {
  ArrowDownTrayIcon,
  ArrowLeftIcon,
  PauseIcon, // Keep PauseIcon if needed for manual pause elsewhere? Or remove? Let's keep for now.
  PlayIcon,  // Keep PlayIcon? Or remove? Let's keep for now.
} from "@heroicons/react/24/solid";
import { closePartialJson, downloadDataAsJson } from "./util/json";
import { SERVER_HOST } from "./constants";
import { ConfirmDeleteModal } from "./ConfirmDeleteModal";
import {
  QATree,
  QATreeNode,
  NodeDims,
  NodeType,
  ScoredQuestion,
} from "./types";
import { InteractiveNodeData } from "./InteractiveNode";
import { AddNodeModal } from "./AddNodeModal";
import { useAppStore } from "./store/appStore";
import { useShallow } from "zustand/react/shallow";
import { Persona } from "./personas";
import { Model, MODELS } from "./models";
// Removed FlowProvider import as it's defined in Flow.tsx
import { ReactFlowProvider } from "reactflow";

interface GraphPageProps {
  seedQuery: string;
  onExit: () => void;
}

type ConvertTreeToFlowProps = (
  tree: QATree,
  setNodeDimsStateSetter: React.Dispatch<React.SetStateAction<NodeDims>>,
  requestDeleteBranch: (edgeId: string) => void,
  // playing: boolean, // Removed playing, as animation is now tied to isGenerating
  generateAnswerForNode: (nodeId: string) => Promise<void>,
  answeringNodes: Set<string>,
  isGenerating: boolean // Pass isGenerating for animation control
) => { nodes: Node<InteractiveNodeData>[]; edges: Edge[] };

// --- Updated convertTreeToFlow ---
export const convertTreeToFlow: ConvertTreeToFlowProps = (
  tree,
  setNodeDimsStateSetter,
  requestDeleteBranch,
  // removed playing
  generateAnswerForNode,
  answeringNodes,
  isGenerating // Added isGenerating
) => {
  const nodes: Node<InteractiveNodeData>[] = [];
  // console.log( // Keep logging if helpful
  //   `convertTreeToFlow: Processing tree with ${
  //     Object.keys(tree).length
  //   } nodes.`
  // );

  Object.keys(tree).forEach((key) => {
    const nodeData = tree[key];
    if (!nodeData) {
      console.warn(`Node data not found for key ${key} during conversion.`);
      return;
    }

    if (!nodeData.nodeID) {
      console.warn(
        `Node data for key ${key} missing nodeID, assigning fallback: ${key}`
      );
      nodeData.nodeID = key; // Assign fallback ID
    }

    // --- Create Question/User Nodes ---
    if (nodeData.nodeType !== 'llm-answer') {
        const primaryNode: Node<InteractiveNodeData> = {
          id: nodeData.nodeID,
          type: "interactiveNode",
          data: {
            // Spread common properties first
            ...nodeData,
            // Explicitly define crucial props for InteractiveNode
            nodeID: nodeData.nodeID,
            setNodeDims: setNodeDimsStateSetter,
            // Only provide onGenerateAnswer for question types
            onGenerateAnswer:
              nodeData.nodeType === "llm-question" ||
              nodeData.nodeType === "user-question"
                ? generateAnswerForNode
                : undefined,
            // Determine isAnswering based on the *question* node ID
            isAnswering:
              (nodeData.nodeType === "llm-question" ||
                nodeData.nodeType === "user-question") &&
              answeringNodes.has(nodeData.nodeID), // Check answeringNodes with the question ID
          },
          position: { x: 0, y: 0 }, // Layout engine will position it
        };
        nodes.push(primaryNode);
    }

    // --- Create Corresponding Answer Nodes (if answer exists) ---
     // Find the corresponding question node for the current key if it's an answer node ID
    const potentialQuestionId = key.startsWith('a-') ? key.substring(2) : null;
    const questionNodeForAnswer = potentialQuestionId ? tree[potentialQuestionId] : null;

    // Or, if the current node is a question node and has an answer
    const isQuestionWithAnswer = (nodeData.nodeType === 'llm-question' || nodeData.nodeType === 'user-question') && nodeData.answer;

    if (questionNodeForAnswer || isQuestionWithAnswer) {
        const questionId = potentialQuestionId ?? nodeData.nodeID;
        const questionNode = questionNodeForAnswer ?? nodeData;
        const answerNodeId = `a-${questionId}`;

        // Make sure we haven't already added this answer node
        if (!nodes.some(n => n.id === answerNodeId) && questionNode.answer) {
             console.log( // Added console log
                `convertTreeToFlow: Found answer for question ${questionId}, creating answer node ${answerNodeId}`
             );
             const answerNodeData: InteractiveNodeData = {
                // Explicitly define properties for answer node
                nodeID: answerNodeId,
                nodeType: "llm-answer",
                question: "", // Answer nodes don't have questions
                answer: questionNode.answer, // Get answer from question node
                parent: questionId, // Parent is the question node
                children: questionNode.children || [], // Children are technically children of the *question* node conceptually
                setNodeDims: setNodeDimsStateSetter,
                // Other optional fields from QATreeNode that might be relevant
                isLoading: questionNode.isLoading, // Reflect loading state if needed
                errorMessage: questionNode.errorMessage, // Reflect error state if needed
                // Fields not applicable to answer nodes
                fileInfo: undefined,
                url: undefined,
                onGenerateAnswer: undefined,
                isAnswering: false,
             };
             const answerGraphNode: Node<InteractiveNodeData> = {
                id: answerNodeId,
                type: "interactiveNode",
                data: answerNodeData,
                position: { x: 0, y: 0 },
             };
             nodes.push(answerGraphNode);
        }
    }
  });


  // --- Create Edges ---
  const edges: Edge[] = [];
  Object.values(tree).forEach((nodeData) => {
    if (!nodeData) return;
    // console.log( // Keep logging if helpful
    //   `convertTreeToFlow: Checking edges for node ${nodeData.nodeID}`
    // );

    // --- Parent -> Child Edges ---
    const parentId = nodeData.parent;
    if (parentId && tree[parentId]) {
      const parentNodeData = tree[parentId];
      // Source is the *answer* node if the parent is a question type AND has an answer
      const sourceId =
        (parentNodeData.nodeType === "llm-question" ||
          parentNodeData.nodeType === "user-question") &&
        parentNodeData.answer
          ? `a-${parentId}` // Link FROM the answer node
          : parentId; // Otherwise link from the parent node itself (e.g., file/webpage)

      const targetId = nodeData.nodeID;

      // Ensure both source and target nodes exist in our generated `nodes` array
      if (
        nodes.some((n) => n.id === sourceId) &&
        nodes.some((n) => n.id === targetId)
      ) {
        // console.log( // Keep logging if helpful
        //   `convertTreeToFlow: Creating edge ${sourceId} -> ${targetId}`
        // );
        edges.push({
          id: `${sourceId}-${targetId}`,
          type: "deleteEdge",
          source: sourceId,
          target: targetId,
          data: { requestDeleteBranch },
          animated: isGenerating, // Animate based on global generating state
          markerEnd: { type: MarkerType.Arrow },
        });
      } else {
        // console.warn( // Keep logging if helpful
        //   `convertTreeToFlow: Source ${sourceId} or Target ${targetId} for edge not found in generated nodes.`
        // );
      }
    }

    // --- Internal Question -> Answer Edges ---
    if (
      (nodeData.nodeType === "llm-question" ||
        nodeData.nodeType === "user-question") &&
      nodeData.answer // Only create edge if answer exists
    ) {
      const questionNodeId = nodeData.nodeID;
      const answerNodeId = `a-${questionNodeId}`;
      // Check if both nodes actually exist in the nodes array before creating edge
      if (
        nodes.some((n) => n.id === questionNodeId) &&
        nodes.some((n) => n.id === answerNodeId)
      ) {
        // console.log( // Keep logging if helpful
        //   `convertTreeToFlow: Creating internal edge ${questionNodeId} -> ${answerNodeId}`
        // );
        edges.push({
          id: `${questionNodeId}-${answerNodeId}`,
          type: "deleteEdge", // Use the deletable edge type
          source: questionNodeId,
          target: answerNodeId,
          animated: isGenerating, // Animate based on global generating state
          markerEnd: { type: MarkerType.Arrow },
          data: { requestDeleteBranch }, // Pass delete callback
        });
      } else {
        // console.warn( // Keep logging if helpful
        //   `convertTreeToFlow: QNode ${questionNodeId} or ANode ${answerNodeId} not found in nodes array for internal edge.`
        // );
      }
    }
  });
  // console.log( // Keep logging if helpful
  //   `convertTreeToFlow: Finished. Nodes created: ${nodes.length}, Edges created: ${edges.length}`
  // );

  return { nodes, edges };
};


// --- getQuestions function remains largely the same, ensure it uses updated tree state ---
async function getQuestions(
  nodeId: string, // Pass node ID instead of the whole node object
): Promise<void> {
   // Get the latest node data and tree from the store *inside* the function
  const { qaTree: treeSnapshot, model: modelKey, persona, addNode, updateNode, setError } = useAppStore.getState();
  const node = treeSnapshot?.[nodeId]; // Get the node using the ID

  if (!node) {
    console.error(`getQuestions: Node ${nodeId} not found in store.`);
    setError(`Node ${nodeId} disappeared before generating questions.`);
    return;
  }
  // Ensure we only generate questions for answer nodes
  if (node.nodeType !== 'llm-answer') {
       console.warn(`getQuestions: Called on non-answer node type ${node.nodeType} for node ${nodeId}. Skipping.`);
       return;
  }

  console.log(`Refactored getQuestions: Processing node ${node.nodeID}`);
  // const { // Removed redundant getState calls
  //   model: modelKey,
  //   persona,
  //   addNode,
  //   updateNode,
  //   setError,
  // } = useAppStore.getState(); // Already got these above

  if (!persona) {
    console.error("getQuestions: Missing persona in store.");
    setError(
      `Missing persona for question generation (node ${node.nodeID})`
    );
    return;
  }

  const person = persona;

  const syncChildrenWithStore = (
    parentNodeId: string, // This should be the *answer* node ID
    generatedQuestions: { question: string }[]
  ) => {
    // --- Find the corresponding *question* node to attach children to ---
    const questionNodeId = parentNodeId.startsWith('a-') ? parentNodeId.substring(2) : null;
    if (!questionNodeId) {
        console.error(`syncChildrenWithStore: Could not derive question node ID from answer node ${parentNodeId}`);
        return;
    }
    const latestQuestionNode = useAppStore.getState().qaTree?.[questionNodeId];
     if (!latestQuestionNode) {
      console.warn(
        `syncChildrenWithStore: Question node ${questionNodeId} (derived from ${parentNodeId}) not found in store.`
      );
      return;
    }
    // --- End find question node ---


    const currentChildrenIds = latestQuestionNode.children || [];
    const existingChildren = currentChildrenIds
      .map((id) => useAppStore.getState().qaTree?.[id])
      .filter(Boolean) as QATreeNode[];

    generatedQuestions.forEach((qData, index) => {
      const newQuestionText = qData.question;
      if (!newQuestionText) return;

       // ID generation needs base question ID
      const newId = `${questionNodeId}-q-${index}`; // e.g., q-0-q-0, q-0-q-1

      // Check if a child with this intended ID *already* exists
      const existingChildWithId = useAppStore.getState().qaTree?.[newId];

      if (existingChildWithId) {
         if (existingChildWithId.question !== newQuestionText) {
           console.log(
            `getQuestions: Updating existing child ${newId} question for parent ${questionNodeId}`
           );
           updateNode(newId, { question: newQuestionText });
         }
      } else {
          console.log(
            `getQuestions: Adding new child ${newId} for parent ${questionNodeId}`
          );
          const newNode: QATreeNode = {
            nodeID: newId,
            parent: parentNodeId, // Parent is the *answer* node ID
            question: newQuestionText,
            answer: "", // New questions start unanswered
            nodeType: "llm-question",
            children: [],
          };
          addNode(newNode); // This action correctly adds to parent's children array
      }
    });

    // Optional: Handle deletion if fewer questions generated than exist
    // (Requires careful logic to decide which to delete)
    // if (existingChildren.length > generatedQuestions.length) { ... }
  };

  // --- Handle synchronous vs asynchronous question generation ---
  if ("getQuestions" in person && person.getQuestions) {
    // Ensure treeSnapshot is passed if needed by the persona method
    const questions = person.getQuestions(node, treeSnapshot || {});
    console.log(
      `getQuestions: Synchronously generated ${questions.length} questions for ${node.nodeID}`
    );
    syncChildrenWithStore(node.nodeID, questions); // Pass answer node ID
    return; // Exit after sync generation
  }

   if (!("getPromptForQuestions" in person && person.getPromptForQuestions)) {
    console.error(
      `Persona ${persona.name} is missing question generation method.`
    );
    setError(`Persona ${persona.name} cannot generate questions.`);
    return;
  }

  // Ensure treeSnapshot is passed if needed by the persona method
  const promptForQuestions = person.getPromptForQuestions(node, treeSnapshot || {});
  let questionsJson = "";
  let finalError: string | null = null;
  // Use a unique ID for the streaming operation related to this node
  const streamNodeId = `qgen-${node.nodeID}`; // e.g., qgen-a-0

  try {
    await window.openai(promptForQuestions, {
      temperature: 1,
      model: modelKey,
      nodeId: streamNodeId, // Use unique stream ID
      onChunk: (message) => {
        // Get latest state *inside* the chunk handler if needed, or rely on closures
        try {
          const parsed = JSON.parse(message);
          const {
            type,
            nodeId: messageNodeId, // ID from the message payload
            content,
            message: errorMessage,
          } = parsed;

          // Ensure message is for *this* question generation stream
          if (messageNodeId !== streamNodeId) return;

          if (type === "chunk" && content) {
            questionsJson += content;
            // Attempt to parse and sync *incrementally*
            const closedJson = closePartialJson(questionsJson);
            try {
              const parsedQuestions = JSON.parse(closedJson);
              if (Array.isArray(parsedQuestions)) {
                 // Pass the answer node ID for syncing
                syncChildrenWithStore(node.nodeID, parsedQuestions);
              }
            } catch (e) {
              // Ignore intermediate parse errors, wait for more chunks
            }
          } else if (type === "error") {
            console.error(
              `getQuestions stream error for node ${node.nodeID}:`,
              errorMessage
            );
            finalError =
              errorMessage || `Unknown stream error generating questions for node ${node.nodeID}.`;
            setError(finalError); // Update global error state
          }
          // Handle 'done' message type if needed
        } catch (e: any) {
          console.error(
            `Error parsing WebSocket message in getQuestions (node ${node.nodeID}):`,
            message,
            e
          );
          // Update global error state
          setError(
            `Failed to parse message during question generation: ${e.message}`
          );
        }
      },
    });
  } catch (error: any) {
    console.error(
      `Error during openai call for getQuestions (node ${node.nodeID}):`,
      error
    );
    finalError = error?.message || `OpenAI call failed for node ${node.nodeID}`;
    setError(finalError); // Update global error state
  }

  // --- Final processing after stream ends ---
  if (finalError) {
    console.error(
      `Final error during question generation for node ${node.nodeID}: ${finalError}`
    );
    // Error already set in stream handler or catch block
    return;
  }

  // Try parsing the complete JSON one last time
  try {
    const finalQuestions = JSON.parse(questionsJson);
    if (Array.isArray(finalQuestions)) {
      console.log(
        `getQuestions: Final processing of ${finalQuestions.length} questions for ${node.nodeID}`
      );
       // Pass the answer node ID for syncing
      syncChildrenWithStore(node.nodeID, finalQuestions);
    } else {
      console.error(
        `Final question JSON is not an array for node ${node.nodeID}:`,
        questionsJson
      );
      setError(`Invalid format received for questions (node ${node.nodeID})`);
    }
  } catch (e: any) {
    console.error(
      `Error parsing final question JSON for node ${node.nodeID}:`,
      e
    );
    setError(
      `Failed to parse final questions JSON (node ${node.nodeID}): ${e.message}`
    );
  }
}


function GraphPage(props: GraphPageProps) {
  const {
    qaTree,
    // playing, // Removed playing state - manage via isGenerating?
    focusedId,
    model,
    persona,
    isGenerating, // Use isGenerating for animation/status
    error,
  } = useAppStore(
    useShallow((state) => ({
      qaTree: state.qaTree,
      // playing: state.playing, // Removed
      focusedId: state.focusedId,
      model: state.model,
      persona: state.persona,
      isGenerating: state.isGenerating,
      error: state.error,
    }))
  );

  const {
    initializeTree,
    // setPlaying, // Removed setPlaying action
    setFocusedId,
    addNode,
    updateNode,
    deleteNodeAndDescendants,
    setError,
    setIsGenerating,
    updateNodeAnswerChunk,
  } = useAppStore(
    useShallow((state) => ({
      initializeTree: state.initializeTree,
      // setPlaying: state.setPlaying, // Removed
      setFocusedId: state.setFocusedId,
      addNode: state.addNode,
      updateNode: state.updateNode,
      deleteNodeAndDescendants: state.deleteNodeAndDescendants,
      setError: state.setError,
      setIsGenerating: state.setIsGenerating,
      updateNodeAnswerChunk: state.updateNodeAnswerChunk,
    }))
  );

  const [nodeDims, setNodeDims] = useState<NodeDims>({});
  const [isConfirmModalOpen, setIsConfirmModalOpen] = useState(false);
  const [edgeToDelete, setEdgeToDelete] = useState<string | null>(null);
  const [isAddNodeModalOpen, setIsAddNodeModalOpen] = useState(false);
  const [addNodeSourceId, setAddNodeSourceId] = useState<string | null>(null);
  const [answeringNodes, setAnsweringNodes] = useState<Set<string>>(new Set());

  const connectingNodeId = useRef<string | null>(null);

  const isTreeInitialized = qaTree !== null && qaTree['q-0'] !== undefined; // Check specifically for q-0

  // --- Initialize Tree ---
  useEffect(() => {
    // Check if the tree is already initialized in the store
    const tree = useAppStore.getState().qaTree;
    if (!tree && props.seedQuery) {
      console.log("GraphPage: Initializing tree in Zustand store.");
      initializeTree(props.seedQuery); // Pass optional persona if needed? No, store handles it.
    }
  }, [initializeTree, props.seedQuery]); // Depend on initializeTree and seedQuery


  // --- REMOVED generatorLoop useEffect ---


  // --- Trigger Initial Answer Generation for q-0 ---
  useEffect(() => {
    // Check if tree is initialized, q-0 exists, and it hasn't been answered/processed yet
    const currentTree = useAppStore.getState().qaTree;
    if (currentTree && currentTree['q-0'] && !currentTree['q-0'].answer && !answeringNodes.has('q-0') && !useAppStore.getState().isGenerating) {
        // Check if 'a-0' already exists to prevent duplicate calls if component re-mounts quickly
        if (!currentTree['a-0']) {
            console.log("GraphPage: Triggering initial answer generation for q-0.");
            generateAnswerForNode('q-0');
        } else {
             console.log("GraphPage: Initial answer node a-0 already exists, skipping initial trigger.");
        }
    }
     // Dependencies: Trigger when q-0 exists, or if answering/generating state changes relevantly
     // Note: Depending directly on qaTree might cause too many runs.
     // Relying on answeringNodes and isGenerating helps control the trigger.
  }, [isTreeInitialized, answeringNodes, isGenerating]); // Add answeringNodes and isGenerating


  // --- generateAnswerForNode function ---
  const generateAnswerForNode = useCallback(
    async (nodeId: string) => { // nodeId here is the *question* node ID (e.g., 'q-0')
      // Store hydration check can remain if needed, but might not be necessary
      // if initial trigger is handled correctly in useEffect
      // ... (hydration check removed for brevity) ...

      console.log(`Manual trigger: generateAnswerForNode(${nodeId})`);
      setAnsweringNodes((prev) => new Set(prev).add(nodeId)); // Add question ID to answering set
      setIsGenerating(true); // Set global generating state
      setError(null); // Clear previous errors

      const {
        model: modelKey,
        persona,
        qaTree: currentTree, // Get latest tree state
        addNode, // Action needed for placeholder
        updateNode, // Action needed to update placeholder
        updateNodeAnswerChunk, // Action for streaming
        // removed setIsGenerating, setError - already called above
      } = useAppStore.getState();


      if (!currentTree) {
          console.error("generateAnswerForNode: qaTree is null!");
          setError("Cannot generate answer: graph not initialized.");
          setAnsweringNodes((prev) => { const next = new Set(prev); next.delete(nodeId); return next; });
          setIsGenerating(false);
          return;
      }

      const questionNode = currentTree[nodeId];
       // Ensure it's a question node we're trying to answer
      if (!questionNode || (questionNode.nodeType !== 'llm-question' && questionNode.nodeType !== 'user-question')) {
          console.warn(`generateAnswerForNode: Invalid or non-question node ID provided: ${nodeId}`);
          setError(`Cannot generate answer for node type: ${questionNode?.nodeType}`);
          setAnsweringNodes((prev) => { const next = new Set(prev); next.delete(nodeId); return next; });
          setIsGenerating(false);
          return;
      }

       // Check for persona
      if (!persona) {
          console.error("generateAnswerForNode: No persona selected");
          setError("No persona selected. Please choose one.");
          setAnsweringNodes((prev) => { const next = new Set(prev); next.delete(nodeId); return next; });
          setIsGenerating(false);
          return;
      }

      // --- Create or Reset Answer Node ---
      const answerNodeId = `a-${nodeId}`;
      console.log(`generateAnswerForNode: Checking/Creating answer node ${answerNodeId}`); // Log entry
      if (!currentTree[answerNodeId]) {
        const answerNode: QATreeNode = {
          nodeID: answerNodeId,
          question: "", // Answer nodes don't have questions
          answer: "",   // Start empty
          nodeType: "llm-answer",
          parent: nodeId, // Link to the question node
          children: [], // Answer nodes don't directly have children in the flow structure (question node does)
          isLoading: true, // Mark as loading initially
          errorMessage: undefined,
        };
        console.log(`generateAnswerForNode: Creating placeholder answer node ${answerNodeId} via addNode`); // Log creation
        addNode(answerNode); // Use store action to add
      } else {
         // If node exists, reset its state for a new generation attempt
         console.log(`generateAnswerForNode: Resetting existing answer node ${answerNodeId}`); // Log reset
         updateNode(answerNodeId, { isLoading: true, errorMessage: undefined, answer: "" });
      }
      // --- End Create or Reset ---


      console.log(
        `generateAnswerForNode: Proceeding to fetch answer for ${nodeId} using model ${modelKey}`
      );


      // --- Get Context (remains the same) ---
      const contextNodes: QATreeNode[] = [];
      let currentAncestorId = questionNode.parent;
      while (currentAncestorId && currentTree[currentAncestorId]) {
        const ancestor = currentTree[currentAncestorId];
        if (
          ancestor.nodeType === "user-file" ||
          ancestor.nodeType === "user-webpage"
        ) {
          contextNodes.unshift(ancestor); // Add to beginning to maintain order
        }
        currentAncestorId = ancestor.parent;
      }
      const context = contextNodes
        .map((n) => {
          if (n.nodeType === "user-file")
            return `Context from file ${n.fileInfo?.name || "untitled"}:\n${
              n.answer
            }`;
          if (n.nodeType === "user-webpage")
            return `Context from webpage ${n.url || "unknown"}:\n${n.answer}`;
          return "";
        })
        .join("\n\n---\n\n");

       // --- Get Prompt for Answer ---
      let prompt = "";
      try {
        // Pass the actual question node and the tree snapshot
        prompt = persona.getPromptForAnswer(questionNode, currentTree);
         // Prepend context if it exists
        if (context) {
            prompt = `Background Context:\n${context}\n\n---\n\n${prompt}`;
        }
      } catch (e: any) {
          console.error(`Error getting prompt from persona ${persona.name} for node ${nodeId}:`, e);
          setError(`Error getting prompt: ${e.message}`);
          updateNode(answerNodeId, { isLoading: false, errorMessage: `Persona prompt error: ${e.message}` });
          setAnsweringNodes((prev) => { const next = new Set(prev); next.delete(nodeId); return next; });
          setIsGenerating(false);
          return;
      }


      // --- Fetch Answer Stream ---
      try {
        // Use window.openai directly now
        await window.openai(prompt, {
           temperature: 1, // Or read from state/config
           model: modelKey,
           nodeId: answerNodeId, // Stream relates to the *answer* node
           onChunk: (message) => {
             try {
                const parsedMessage = JSON.parse(message);
                const {
                  type,
                  nodeId: messageNodeId,
                  content,
                  message: errorMessage,
                } = parsedMessage;

                // Ensure the chunk is for *this* answer node
                if (messageNodeId !== answerNodeId) return;

                if (type === "chunk" && content) {
                   // Update the *answer* node's answer field
                  useAppStore.getState().updateNodeAnswerChunk(answerNodeId, content);
                } else if (type === "error") {
                  console.error(
                    `generateAnswerForNode: Stream error for node ${answerNodeId}:`,
                    errorMessage
                  );
                  // Update the *answer* node with error message
                  useAppStore.getState().updateNode(answerNodeId, {
                      isLoading: false, // Stop loading
                      errorMessage: errorMessage || `Stream error for ${answerNodeId}`
                  });
                  // Potentially update the question node too? No, error is on answer.
                } else if (type === "done") {
                    // Mark the *answer* node as no longer loading
                    console.log(`generateAnswerForNode: Stream finished for ${answerNodeId}.`);
                    useAppStore.getState().updateNode(answerNodeId, { isLoading: false });
                     // --- Trigger Question Generation ---
                    // Pass the *answer* node ID to getQuestions
                    console.log(`generateAnswerForNode: Triggering getQuestions for answer node ${answerNodeId}`);
                    getQuestions(answerNodeId); // Call getQuestions after answer is done
                    // --- End Trigger Question Generation ---
                }
             } catch (e) {
                console.error(
                  `generateAnswerForNode: Error parsing stream message for ${answerNodeId}:`,
                  message,
                  e
                );
                 useAppStore.getState().updateNode(answerNodeId, {
                      isLoading: false,
                      errorMessage: "Failed to parse stream message."
                  });
             }
           }
        });

        // Note: 'done' logic including getQuestions call is now inside onChunk handler

      } catch (error: any) {
        console.error("Error calling window.openai or processing stream:", error);
        setError(`Failed to get answer: ${error.message}`);
        // Update the *answer* node's state on error
        useAppStore.getState().updateNode(answerNodeId, { isLoading: false, errorMessage: error.message });
      } finally {
        // Clean up states related to the *question* node
        setAnsweringNodes((prev) => {
          const next = new Set(prev);
          next.delete(nodeId); // Remove question ID from answering set
          return next;
        });
        setIsGenerating(false); // Set global generating state to false
        console.log(`generateAnswerForNode: Finished processing for question node ${nodeId}`);
      }
    },
    // Add necessary dependencies for useCallback
    [setError, setIsGenerating, addNode, updateNode, updateNodeAnswerChunk]
  );

  // --- requestDeleteBranch and handleConfirmDelete remain the same ---
  const requestDeleteBranch = useCallback((edgeId: string) => {
    console.log("Requesting confirmation to delete edge:", edgeId);
    setEdgeToDelete(edgeId);
    setIsConfirmModalOpen(true);
  }, []);

  const handleConfirmDelete = useCallback(() => {
    if (!edgeToDelete) return;
    console.log("Confirmed deletion for edge:", edgeToDelete);

    // Logic to find the target node to start deletion from
    const edgeParts = edgeToDelete.split("-");
    let targetNodeId: string | null = null;

    // Heuristic parsing: Assumes target ID is the last part(s)
    if (edgeParts.length >= 2) {
       // Attempt to reconstruct target ID (handles IDs like 'a-q-0', 'q-0-q-1')
       let potentialTarget = edgeParts[edgeParts.length - 1];
       if ((potentialTarget === '0' || potentialTarget === '1') && edgeParts.length >= 3) {
           potentialTarget = edgeParts.slice(edgeParts.length - 2).join('-'); // Try last two parts
           if (!useAppStore.getState().qaTree?.[potentialTarget] && edgeParts.length >= 4) {
               potentialTarget = edgeParts.slice(edgeParts.length - 3).join('-'); // Try last three parts (e.g., q-0-q-1)
           }
       }

       if (useAppStore.getState().qaTree?.[potentialTarget]) {
            targetNodeId = potentialTarget;
       } else if (useAppStore.getState().qaTree?.[edgeParts.slice(1).join('-')]) {
           // Fallback for simple source-target
           targetNodeId = edgeParts.slice(1).join('-');
       } else {
            console.error(`Could not reliably parse target node ID from edge: ${edgeToDelete}`);
       }

       console.log(`Parsed edge ${edgeToDelete}: Determined Target=${targetNodeId}`);
    } else {
      console.error(`Could not parse edge ID: ${edgeToDelete}`);
    }

    if (!targetNodeId) {
      console.error(
        `Could not determine deletion target from edge ${edgeToDelete}`
      );
      setError(
          `Failed to determine deletion target from edge ${edgeToDelete}.`
        );
      setIsConfirmModalOpen(false);
      setEdgeToDelete(null);
      return;
    }

    // Use the determined target node ID for deletion
    console.log(
      `Calling deleteNodeAndDescendants action for root: ${targetNodeId}`
    );
    deleteNodeAndDescendants(targetNodeId);

    setIsConfirmModalOpen(false);
    setEdgeToDelete(null);
  }, [edgeToDelete, deleteNodeAndDescendants, setError]); // Add setError dependency


  // --- onConnectStart/End remain the same ---
  const onConnectStart = useCallback(
    (
      _event: React.MouseEvent | React.TouchEvent,
      { nodeId }: { nodeId: string | null }
    ) => {
      connectingNodeId.current = nodeId;
    },
    []
  );

  const onConnectEnd = useCallback((event: MouseEvent | TouchEvent) => {
    const target = event.target as Element;
    const targetIsPane = target.classList.contains("react-flow__pane");
    const sourceNodeId = connectingNodeId.current;
    const currentTree = useAppStore.getState().qaTree; // Get latest tree

    if (targetIsPane && sourceNodeId && currentTree) {
        const sourceNode = currentTree[sourceNodeId];
        // Allow connecting from answer nodes or user nodes
        const isValidSource = sourceNode && (
             sourceNode.nodeType === "llm-answer" ||
             sourceNode.nodeType === "user-file" ||
             sourceNode.nodeType === "user-webpage"
            );

      if (isValidSource) {
        console.log(`Connection ended on pane from valid source: ${sourceNodeId}`);
        setAddNodeSourceId(sourceNodeId);
        setIsAddNodeModalOpen(true);
      } else {
        console.log(
          `Connection end from invalid source node type/state: ${sourceNodeId} (Type: ${sourceNode?.nodeType})`
        );
      }
    } else {
         console.log(`Connection ended. Target is pane: ${targetIsPane}, Source Node ID: ${sourceNodeId}`);
    }
    connectingNodeId.current = null; // Reset connecting node ID
  }, []); // Removed dependencies, relies on getState inside


  // --- Node/Edge Memoization ---
  const { nodes, edges } = useMemo(() => {
    if (!qaTree) {
      // console.log("useMemo: qaTree is null, returning empty."); // Keep logging if helpful
      return { nodes: [], edges: [] };
    }
    // console.log("useMemo: Recalculating nodes/edges for React Flow."); // Keep logging if helpful
    return convertTreeToFlow(
      qaTree,
      setNodeDims,
      requestDeleteBranch,
      // removed playing
      generateAnswerForNode,
      answeringNodes,
      isGenerating // Pass isGenerating
    );
  }, [
    qaTree, // Depend on the tree structure
    setNodeDims, // Stable setter ref
    requestDeleteBranch, // Stable callback
    generateAnswerForNode, // Stable callback
    answeringNodes, // State tracking answering nodes
    isGenerating, // State tracking global generation
  ]);

  // Note: animatedEdges memoization is removed as animation is handled inside convertTreeToFlow


  // --- Removed handlePlayPauseClick ---


  // --- handleAddNodeFromModal remains the same ---
  const handleAddNodeFromModal = (type: NodeType) => {
      if (addNodeSourceId) {
        let prefix = "u"; // Default prefix
        if (type === "user-question") prefix = "uq";
        else if (type === "user-file") prefix = "uf";
        else if (type === "user-webpage") prefix = "uw";

        const newIdSuffix = Math.random().toString(36).substring(2, 9);
        // Ensure the source ID part used in the new ID is clean and not overly long
        const cleanSourceId = addNodeSourceId.replace(/[^a-zA-Z0-9_-]/g, '').substring(0, 20); // Limit length
        const newNodeId = `${prefix}-${cleanSourceId}-${newIdSuffix}`;

        const newNode: QATreeNode = {
          nodeID: newNodeId,
          nodeType: type,
          question: "", // Initialize appropriately based on type
          answer: "",   // Initialize appropriately based on type
          parent: addNodeSourceId, // Link to the node dragged from
          children: [],
          isLoading: false, // Default state
        };
        addNode(newNode); // Uses store action
        console.log(`Added new node ${newNodeId} from modal, parent: ${addNodeSourceId}`);
      } else {
          console.warn("handleAddNodeFromModal called without addNodeSourceId");
      }
      setIsAddNodeModalOpen(false); // Close modal
      setAddNodeSourceId(null); // Reset source ID
    };


  // --- Loading State ---
  if (!isTreeInitialized) { // Simplified check
    console.log("GraphPage: Rendering Loading state because tree is not initialized.");
    return <div>Loading...</div>;
  }

  // --- Get Display Info ---
  const currentModelInfo = model ? MODELS[model] : null;
  const currentPersonaInfo = persona; // Already have the persona object


  // --- JSX RETURN BLOCK ---
  return (
    <div className="text-sm h-screen w-screen relative overflow-hidden">
      {/* Error Display */}
      {error && (
        <div className="fixed top-0 left-1/2 transform -translate-x-1/2 mt-2 z-50 bg-red-100 border border-red-400 text-red-700 px-4 py-2 rounded shadow-md max-w-md text-center">
          <strong>Error:</strong> {error}
          <button
            onClick={() => setError(null)} // Use store action
            className="ml-4 text-red-500 hover:text-red-700 font-bold"
          >
            X
          </button>
        </div>
      )}

      {/* Flow Rendering: Provider first, then the Flow component with props */}
      <ReactFlowProvider>
        <Flow
          flowNodes={nodes}
          flowEdges={edges} // Pass calculated edges (animation handled internally)
          nodeDims={nodeDims}
          onConnectStart={onConnectStart}
          onConnectEnd={onConnectEnd}
          deleteBranch={requestDeleteBranch}
        />
      </ReactFlowProvider>

      {/* Add Node Modal */}
      <AddNodeModal
        isOpen={isAddNodeModalOpen}
        onClose={() => {
          setIsAddNodeModalOpen(false);
          setAddNodeSourceId(null);
        }}
        onAddNode={handleAddNodeFromModal}
        sourceNodeId={addNodeSourceId}
      />

      {/* Controls Overlay */}
      <div className="fixed right-4 bottom-4 flex items-center space-x-2 z-20">
        {/* Download Button */}
        {SERVER_HOST.includes("localhost") && (
          <div
            className="bg-black/40 p-2 flex items-center justify-center rounded cursor-pointer hover:text-green-400 backdrop-blur"
            onClick={() => {
              const currentTree = useAppStore.getState().qaTree;
              if (!currentTree) return;
              const filename = (props.seedQuery || "graph-export")
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, "-")
                .substring(0, 50);
              const dict: any = {
                version: "1.0.0", // Update if schema changes
                persona: useAppStore.getState().persona?.name,
                model: useAppStore.getState().model,
                seedQuery: props.seedQuery,
                tree: currentTree,
              };
              downloadDataAsJson(dict, filename);
            }}
            title="Download Graph Data (JSON)"
          >
            <ArrowDownTrayIcon className="w-5 h-5" />
          </div>
        )}
        {/* Info & Status Indicator */}
        <div className="bg-black/40 p-2 pl-3 rounded flex items-center space-x-3 backdrop-blur touch-none">
          <div className="text-white/60 select-none">
            {currentPersonaInfo?.name ?? "Default Persona"} •{" "}
            {currentModelInfo?.name ?? "Default Model"}
          </div>
          {/* Removed Play/Pause button - replaced with generating indicator? */}
           {isGenerating && (
             <div title="Generating..." className="flex items-center justify-center text-green-400">
                <svg className="animate-spin h-5 w-5 mr-1" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span>Generating...</span>
             </div>
            )}
        </div>
      </div>
      {/* Exit Button */}
      <div
        onClick={props.onExit}
        className="fixed top-4 left-4 bg-black/40 rounded p-2 cursor-pointer hover:bg-black/60 backdrop-blur touch-none z-20"
        title="Exit to Start Page"
      >
        <ArrowLeftIcon className="w-5 h-5" />
      </div>

      {/* Confirm Delete Modal */}
      <ConfirmDeleteModal
        isOpen={isConfirmModalOpen}
        onClose={() => {
          setIsConfirmModalOpen(false);
          setEdgeToDelete(null);
        }}
        onConfirm={handleConfirmDelete}
      />
    </div>
  );
}

export default GraphPage;
```

**Summary of Key Changes:**

1.  **Removed `generatorLoop`:** The `useEffect` responsible for automatic node processing is gone.
2.  **Trigger Initial Answer:** A new `useEffect` calls `generateAnswerForNode('q-0')` when the page loads, ensuring the first answer process starts.
3.  **User-Driven Answers:** Subsequent answers are only generated when the user clicks the "Answer" button in an `InteractiveNode` (handled by `onGenerateAnswer` prop passed down).
4.  **`getQuestions` Call:** The `getQuestions` function is now called from within the `onChunk` handler of `generateAnswerForNode` when the `type === 'done'` message arrives, ensuring questions are generated *after

---

_**User**_

pls continue your last response

---

_**Assistant**_

My apologies, I was cut off. Continuing the summary of changes in `app/src/GraphPage.tsx`:

**Summary of Key Changes:**

1.  **Removed `generatorLoop`:** The `useEffect` responsible for automatic node processing is gone.
2.  **Trigger Initial Answer:** A new `useEffect` calls `generateAnswerForNode('q-0')` when the page loads, ensuring the first answer process starts.
3.  **User-Driven Answers:** Subsequent answers are only generated when the user clicks the "Answer" button in an `InteractiveNode` (handled by `onGenerateAnswer` prop passed down).
4.  **`getQuestions` Call:** The `getQuestions` function is now called from within the `onChunk` handler of `generateAnswerForNode` when the `type === 'done'` message arrives, ensuring questions are generated *after* the answer stream is complete.
5.  **Cleaned up State:** Removed the `playing` state and associated logic, relying on `isGenerating` for status indication and animations.
6.  **Refined `convertTreeToFlow`:** Clarified how answer nodes are created and linked, ensuring consistency.
7.  **Logging:** Added logs to trace the creation of the answer node (`a-0`) and the triggering of `getQuestions`.

These changes should align the application with the desired user-driven flow:

*   Submit question on `StartPage`.
*   `GraphPage` loads, showing only `q-0`.
*   `GraphPage` automatically calls `generateAnswerForNode('q-0')`.
*   As the stream comes in via WebSocket, `a-0` appears and populates.
*   Once the answer stream for `a-0` is finished, `getQuestions` is called for `a-0`.
*   New question nodes (e.g., `q-0-q-0`, `q-0-q-1`) appear, linked from `a-0`.
*   The flow waits for the user to click "Answer" on one of the new question nodes.

Please apply these changes to `app/src/GraphPage.tsx`. I will make the edit now.

---

_**User**_

error on line 133 in @GraphPage.tsx 

---

_**Assistant**_

Okay, I see the error. It's occurring in `GraphPageExample.tsx`, not `GraphPage.tsx`.

The error `Argument of type 'boolean' is not assignable to parameter of type '(nodeId: string) => Promise<void>'` on line 133 of `src/GraphPageExample.tsx` happened because we changed the parameters for the `convertTreeToFlow` function (removing `playing` and adding `isGenerating`), but we didn't update the call to it within the `GraphPageExample.tsx` component.

I need to adjust that call site. Since `GraphPageExample` displays static example data, we don't need a real `generateAnswerForNode` function, `answeringNodes`, or `isGenerating` state. We can pass dummy values or appropriate static values.

I'll fix the call in `GraphPageExample.tsx`.

```typescript
import React, { useCallback, useEffect, useMemo, useState } from "react";
import { Flow } from "./Flow";
import { Edge, MarkerType, Node } from "reactflow";
import { ArrowDownTrayIcon, ArrowLeftIcon } from "@heroicons/react/24/solid";
import { downloadDataAsJson } from "./util/json";
import { SERVER_HOST } from "./constants";
import { QATree, NodeDims } from "./types";
import { convertTreeToFlow } from "./GraphPage"; // Import the updated function
import { Example } from "./StartPage";
import { InteractiveNodeData } from "./InteractiveNode";
import { ReactFlowProvider } from "reactflow";
import { MODELS } from "./models";
import { PERSONAS } from "./personas";

interface GraphPageExampleProps {
  example: Example;
  onExit: () => void;
}

// Dummy function matching the required signature for generateAnswerForNode
const dummyGenerateAnswer = async (nodeId: string): Promise<void> => {
  console.warn(
    `generateAnswerForNode called in example mode for ${nodeId}, this should not happen.`
  );
  return Promise.resolve();
};

// Dummy function for delete branch request
const dummyRequestDeleteBranch = (edgeId: string): void => {
  console.warn(
    `requestDeleteBranch called in example mode for ${edgeId}, this should not happen.`
  );
};

export function GraphPageExample(props: GraphPageExampleProps) {
  const { example, onExit } = props;
  const [nodeDims, setNodeDims] = useState<NodeDims>({});
  const [internalTree, setInternalTree] = useState<QATree>(example.tree);

  // Update internal tree if example prop changes
  useEffect(() => {
    setInternalTree(example.tree);
  }, [example.tree]);

  const connectingNodeId = React.useRef<string | null>(null);

  const onConnectStart = useCallback(
    (
      _event: React.MouseEvent | React.TouchEvent,
      { nodeId }: { nodeId: string | null }
    ) => {
      connectingNodeId.current = nodeId;
    },
    []
  );

  // In example mode, connecting to the pane shouldn't do anything
  const onConnectEnd = useCallback((event: MouseEvent | TouchEvent) => {
    connectingNodeId.current = null;
    console.log("Connect end in example mode.");
  }, []);

  const { nodes, edges } = useMemo(() => {
    if (!internalTree) {
      return { nodes: [], edges: [] };
    }
    // --- Update the call to convertTreeToFlow ---
    return convertTreeToFlow(
      internalTree,
      setNodeDims,
      dummyRequestDeleteBranch, // Pass dummy delete function
      dummyGenerateAnswer, // Pass dummy generate function
      new Set<string>(), // Pass empty Set for answeringNodes
      false // Pass false for isGenerating
    );
    // --- End update ---
  }, [internalTree, setNodeDims]); // Keep dependencies minimal for static example

  const currentModelInfo = MODELS[example.model];
  const currentPersonaInfo = PERSONAS[example.persona];
  const seedQuery =
    internalTree["q-0"]?.question ?? internalTree["0"]?.question ?? "Example";

  return (
    <div className="text-sm h-screen w-screen relative overflow-hidden">
      <ReactFlowProvider>
        <Flow
          flowNodes={nodes}
          flowEdges={edges}
          nodeDims={nodeDims}
          onConnectStart={onConnectStart}
          onConnectEnd={onConnectEnd} // Pass connect end handler
          deleteBranch={dummyRequestDeleteBranch} // Pass dummy delete handler
        />
      </ReactFlowProvider>

      {/* Removed AddNodeModal and ConfirmDeleteModal as they aren't used in example */}

      <div className="fixed right-4 bottom-4 flex items-center space-x-2 z-20">
        {/* Download Button (optional, can keep or remove for examples) */}
        {SERVER_HOST.includes("localhost") && (
          <div
            className="bg-black/40 p-2 flex items-center justify-center rounded cursor-pointer hover:text-green-400 backdrop-blur"
            onClick={() => {
              if (!internalTree) return;
              const filename = (seedQuery || "graph-export")
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, "-")
                .substring(0, 50);
              const dict: any = {
                version: "1.0.0",
                persona: example.persona,
                model: example.model,
                seedQuery: seedQuery,
                tree: internalTree,
              };
              downloadDataAsJson(dict, filename);
            }}
            title="Download Graph Data (JSON)"
          >
            <ArrowDownTrayIcon className="w-5 h-5" />
          </div>
        )}
        {/* Info Display */}
        <div className="bg-black/40 p-2 pl-3 rounded flex items-center space-x-3 backdrop-blur touch-none">
          <div className="text-white/60 select-none">
            {currentPersonaInfo?.name ?? example.persona} •{" "}
            {currentModelInfo?.name ?? example.model}
          </div>
          {/* No generating indicator needed for static example */}
        </div>
      </div>
      {/* Exit Button */}
      <div
        onClick={onExit}
        className="fixed top-4 left-4 bg-black/40 rounded p-2 cursor-pointer hover:bg-black/60 backdrop-blur touch-none z-20"
        title="Exit Example"
      >
        <ArrowLeftIcon className="w-5 h-5" />
      </div>
    </div>
  );
}
```

This updates the arguments passed to `convertTreeToFlow` to match the new function signature, resolving the TypeScript error.

---

_**User**_

and you fucking ignored the issue on line 133, which is now 138 thanks to those updates that did fuck knows

---

_**Assistant**_



---



---

