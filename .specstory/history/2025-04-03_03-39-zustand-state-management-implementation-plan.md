<!-- Generated by SpecStory -->

# Zustand State Management Implementation Plan (2025-04-03 14:09:55)

_**User**_

It has been identified that the whybot app will benefit from:
- simpler state management. The mix of useRef mutations followed by structuredClone into useState (GraphPage.tsx) is complex and potentially inefficient/error-prone. A dedicated state library or more disciplined use of immutable updates with useState/useReducer could improve clarity.
- Documenting the `QATree` structure and the generator pattern more thoroughly with comments.
- Significantly improve inline commenting, especially for algorithms, state management, and API interactions.
- Identifying and marking with TODO unused or placeholder code (e.g., empty util files or legacy code)

i would like you to go over the codebase in @src and first, identify all files that currently have state management.

Create a unified implementation plan to implement zustand state management. That has example snippetes for every expected state task that will be implemented. 

---

_**Assistant**_

Okay, let's outline a plan to refactor the state management in your `@src` directory using Zustand, based on the issues identified and the provided `state-management.mdc` rules.

**1. Identifying Current State Management Locations**

Based on the file list and common React patterns, state management is likely concentrated in these areas:

*   **`GraphPage.tsx`**: This is explicitly mentioned as the primary location for complex state (`qaTree`, generator logic, node/edge states, focus, playing status) using the `useRef` + `structuredClone` + `useState` pattern. This will be the main target for refactoring.
*   **`Flow.tsx`**: Likely manages React Flow specific state (nodes, edges, viewport), potentially interacting with the global state from `GraphPage.tsx`. We'll need to see how it receives and updates data like nodes/edges.
*   **`InteractiveNode.tsx` / `FadeoutTextNode.tsx`**: These custom nodes might have internal state, but more importantly, they will need to *read* global state (like node data from `qaTree`) and potentially trigger global actions (like focusing or updating node content).
*   **`APIKeyModal.tsx`**: Manages the API key state, likely using `useState`. This seems like a good candidate for global state.
*   **`AddNodeModal.tsx`**: Manages form state for adding a new node and needs to trigger an action to add the node to the global `qaTree`.
*   **`StartPage.tsx`**: May manage state related to initial setup or loading, potentially including model/persona selection.
*   **`App.tsx`**: Might hold top-level state or context providers, although routing seems to be its main job.
*   **`FocusedContext.tsx`**: Currently uses React Context for focus management. This state (`focusedId`) should be migrated to the Zustand store.

Other components likely use `useState` for local UI state, which is generally fine to leave as is unless it represents shared application state.

**2. Zustand Implementation Plan**

This plan follows the guidelines in `state-management.mdc`.

**Goal:** Consolidate shared application state into a single Zustand store (`useAppStore`) using `immer` for immutable updates and `devtools` for debugging, replacing the `useRef`/`useState` combination in `GraphPage.tsx` and other scattered state logic.

**Steps & Example Snippets:**

**A. Define the Store (`src/store/appStore.ts`)**

*   Create a new directory `src/store`.
*   Create `src/store/appStore.ts`.
*   Define the state interface and the store using `create`, `immer`, and `devtools`.

```typescript
// src/store/appStore.ts
import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { devtools } from 'zustand/middleware/devtools';
import { QATree, QATreeNode, Persona } from '../types'; // Adjust path as needed
import { availableModels } from '../models'; // Adjust path as needed
import { initialTree } from '../initialElements'; // Assuming initial tree structure is defined here

interface AppState {
  // Core State
  qaTree: QATree;
  playing: boolean;
  focusedId: string | null;
  apiKey: string | null;
  model: string; // Or use a specific type/enum
  persona: Persona | null; // Or use a specific type

  // Loading/Status State (Optional - can be added as needed)
  isGenerating: boolean; // Example: useful for generator status
  // ... other potential states like error messages

  // Actions
  setPlaying: (isPlaying: boolean) => void;
  setFocusedId: (id: string | null) => void;
  setApiKey: (key: string | null) => void;
  setModel: (model: string) => void;
  setPersona: (persona: Persona | null) => void;
  setIsGenerating: (generating: boolean) => void;

  // --- QATree Actions ---
  // Replaces direct manipulation + structuredClone
  setInitialTree: (tree: QATree) => void; // For loading saved graphs
  addNode: (node: QATreeNode) => void;
  updateNode: (nodeId: string, changes: Partial<QATreeNode>) => void;
  deleteNode: (nodeId: string) => void; // Needs careful implementation for children/parent links
  updateNodeAnswerChunk: (nodeId: string, chunk: string) => void; // For streaming
  // ... potentially more specific actions like addChild, removeChild etc.
}

export const useAppStore = create<AppState>()(
  devtools(
    immer((set, get) => ({
      // Initial State
      qaTree: initialTree, // Or load from storage/default
      playing: true,
      focusedId: null,
      apiKey: null, // Or load from localStorage
      model: availableModels[0].value, // Default model
      persona: null, // Default persona
      isGenerating: false,

      // --- Actions Implementation ---
      setPlaying: (isPlaying) => set({ playing: isPlaying }),
      setFocusedId: (id) => set({ focusedId: id }),
      setApiKey: (key) => set({ apiKey: key }), // Consider persisting to localStorage here or separately
      setModel: (model) => set({ model: model }),
      setPersona: (persona) => set({ persona: persona }),
      setIsGenerating: (generating) => set({ isGenerating: generating }),

      setInitialTree: (tree) => set({ qaTree: tree }),

      addNode: (node) =>
        set((state) => {
          if (state.qaTree[node.nodeID]) {
            console.warn(`Attempted to add duplicate node: ${node.nodeID}`);
            return; // Prevent overwriting
          }
          state.qaTree[node.nodeID] = node;
          // Add to parent's children array (Immer handles immutability)
          if (node.parent && state.qaTree[node.parent]) {
            const parent = state.qaTree[node.parent];
            if (!parent.children) {
              parent.children = [];
            }
            if (!parent.children.includes(node.nodeID)) {
              parent.children.push(node.nodeID);
            }
          }
        }),

      updateNode: (nodeId, changes) =>
        set((state) => {
          const node = state.qaTree[nodeId];
          if (node) {
            Object.assign(node, changes); // Immer tracks mutations
          } else {
            console.warn(`Attempted to update non-existent node: ${nodeId}`);
          }
        }),

      updateNodeAnswerChunk: (nodeId, chunk) =>
        set((state) => {
            const node = state.qaTree[nodeId];
            if (node) {
                if (node.answer === undefined) node.answer = '';
                node.answer += chunk; // Append chunk - Immer handles update
            } else {
                console.warn(`Attempted to stream to non-existent node: ${nodeId}`);
            }
        }),

      deleteNode: (nodeId) =>
        set((state) => {
          const nodeToDelete = state.qaTree[nodeId];
          if (!nodeToDelete) return;

          // 1. Remove from parent's children array
          if (nodeToDelete.parent && state.qaTree[nodeToDelete.parent]) {
            const parent = state.qaTree[nodeToDelete.parent];
            if (parent.children) {
              parent.children = parent.children.filter(id => id !== nodeId);
            }
          }

          // 2. Recursively delete children (or handle orphans depending on desired logic)
          const childrenToDelete = [...(nodeToDelete.children || [])]; // Copy children array
          childrenToDelete.forEach(childId => {
              // Recursive call might be complex with Immer's draft state.
              // Easier to collect all descendants and delete iteratively.
              // For now, just deleting direct children referenced. Revisit if deep deletion needed.
              if (state.qaTree[childId]) {
                  // Optional: Set child's parent to null or handle differently
                  delete state.qaTree[childId];
              }
          });

          // 3. Delete the node itself
          delete state.qaTree[nodeId];

          // 4. Clear focus if the deleted node was focused
          if (get().focusedId === nodeId) {
              state.focusedId = null;
          }
        }),

    })),
    { name: 'WhyBotAppStore' } // Name for Redux DevTools
  )
);

// --- Selectors (Optional but Recommended for Reusability) ---
// Place outside create or use a separate file e.g., store/selectors.ts

export const selectQaTree = (state: AppState) => state.qaTree;
export const selectPlaying = (state: AppState) => state.playing;
export const selectFocusedId = (state: AppState) => state.focusedId;
export const selectApiKey = (state: AppState) => state.apiKey;
// ... and so on
```

**B. Refactor Components to Use the Store**

*   Remove `useState`, `useRef`, `useReducer` calls related to the state now managed by Zustand.
*   Remove `Context.Provider` for `FocusedContext`.
*   Use `useAppStore` hook with selectors. Remember `useShallow` for multiple values.

*   **Example: `GraphPage.tsx` (Conceptual)**

    ```typescript
    import React, { useEffect /* remove useState, useRef, useReducer */ } from 'react';
    import { useShallow } from 'zustand/react/shallow';
    import { useAppStore, selectQaTree /* import other selectors/actions */ } from '../store/appStore';
    import Flow from './Flow';
    // ... other imports

    function GraphPage() {
      // Replace useState/useRef for tree, playing, focusedId etc.
      // const [resultTree, setResultTree] = useState<QATree>(initialTree); // REMOVE
      // const qaTreeRef = useRef<QATree>(resultTree); // REMOVE

      // Select needed state slices
      const { qaTree, playing, focusedId, apiKey, model, persona } = useAppStore(
        useShallow((state) => ({
          qaTree: state.qaTree, // or use selectQaTree
          playing: state.playing,
          focusedId: state.focusedId,
          apiKey: state.apiKey,
          model: state.model,
          persona: state.persona,
        }))
      );

      // Get actions (stable references, no need for useCallback usually)
      const setPlaying = useAppStore((state) => state.setPlaying);
      const setFocusedId = useAppStore((state) => state.setFocusedId);
      const addNode = useAppStore((state) => state.addNode);
      const updateNode = useAppStore((state) => state.updateNode);
      // ... get other actions

      // --- Refactor Effects and Callbacks ---

      // Example: Node Generator Logic
      useEffect(() => {
        // The generator function itself might live outside the component or in a util
        // It needs access to state and actions.
        const runGenerator = async () => {
           // Access state *directly* when needed inside async logic outside React render cycle
           const currentApiKey = useAppStore.getState().apiKey;
           const currentTree = useAppStore.getState().qaTree; // Use getState() for latest state snapshot
           const currentModel = useAppStore.getState().model;

           if (!currentApiKey || !useAppStore.getState().playing) return; // Check state via getState()

           // Get actions from outside closure (or via getState() if preferred)
           const updateChunk = useAppStore.getState().updateNodeAnswerChunk;
           const markGenerating = useAppStore.getState().setIsGenerating;

           markGenerating(true);
           try {
               // ... existing generator logic ...
               // Call OpenAI...
               // On chunk received:
               // updateChunk(targetNodeId, chunk); // Call action via getState() reference

           } finally {
               markGenerating(false);
           }
        };

        // Trigger generator based on dependencies (e.g., tree changes, playing status)
         if (playing /* && other conditions */) {
             // runGenerator(); // Decide precise trigger conditions
         }

      }, [playing /* other relevant deps */]);


      // Example: Handling Focus (passed down or handled in Node component)
      const handleNodeClick = (nodeId: string) => {
        setFocusedId(nodeId); // Call the action
      };

      // Example: Adding a Node (e.g., from AddNodeModal callback)
      const onAddNode = (newNodeData: Omit<QATreeNode, 'nodeID'>) => {
          const newNode: QATreeNode = {
              ...newNodeData,
              nodeID: generateUniqueId(), // replace with actual ID generation
              // ... set parent, position etc.
          };
          addNode(newNode); // Call the action
      };

      // --- Rendering ---
      // Pass necessary data and actions down to children (e.g., Flow)
      return (
        <div>
          {/* Pass state slices and actions as props */}
          <Flow
            nodes={reactFlowNodesFromQaTree(qaTree)} // Convert tree to React Flow format
            edges={reactFlowEdgesFromQaTree(qaTree)}
            focusedId={focusedId}
            onNodeClick={handleNodeClick}
            // ... other props
          />
          {/* Other UI elements using store state/actions */}
          <button onClick={() => setPlaying(!playing)}>
            {playing ? 'Pause' : 'Play'}
          </button>
        </div>
      );
    }

    // Helper function (potentially in utils)
    function reactFlowNodesFromQaTree(qaTree: QATree) {
        // Convert your QATree structure to React Flow's node format [{ id, data, position, type... }]
        return Object.values(qaTree).map(node => ({
             id: node.nodeID,
             type: 'interactiveNode', // Or determine based on node.nodeType
             position: node.position || { x: 0, y: 0 }, // Ensure position exists
             data: { label: node.question, answer: node.answer /* pass necessary node data */ }
        }));
    }
     function reactFlowEdgesFromQaTree(qaTree: QATree) {
        // Convert parent/child relationships to React Flow's edge format [{ id, source, target, type... }]
        const edges: any[] = [];
         Object.values(qaTree).forEach(node => {
             if(node.children) {
                 node.children.forEach(childId => {
                     edges.push({
                         id: `e-${node.nodeID}-${childId}`,
                         source: node.nodeID,
                         target: childId,
                         type: 'deletableEdge', // Or your custom edge type
                     });
                 });
             }
         });
        return edges;
    }
    ```

*   **Example: `InteractiveNode.tsx`**

    ```typescript
    import React from 'react';
    import { useShallow } from 'zustand/react/shallow';
    import { useAppStore } from '../store/appStore'; // Adjust path

    function InteractiveNode({ id, data }: { id: string; data: any }) {
      // Select only the state needed for this *specific* node instance
      // Avoid selecting the whole tree here for performance.
      // If data passed from Flow is sufficient, use that.
      // If more reactive data needed (e.g., isFocused):
      const isFocused = useAppStore((state) => state.focusedId === id);
      // Or select specific node data if not passed via props 'data':
      // const nodeData = useAppStore(state => state.qaTree[id]);

      // Get actions needed
      const setFocusedId = useAppStore((state) => state.setFocusedId);
      const updateNode = useAppStore((state) => state.updateNode); // For edits

      const handleFocus = () => {
        setFocusedId(id);
      };

      const handleAnswerChange = (newAnswer: string) => {
         // Example: If node allows editing answer directly
         updateNode(id, { answer: newAnswer });
      };

      // Render node using props.data and isFocused state
      return (
        <div onClick={handleFocus} className={isFocused ? 'focused' : ''}>
          <div>{data.label}</div>
          {/* Example: Render answer, potentially editable */}
          <textarea value={data.answer || ''} onChange={(e) => handleAnswerChange(e.target.value)} />
          {/* ... other node elements ... */}
        </div>
      );
    }
    ```

*   **Example: `APIKeyModal.tsx`**

    ```typescript
    import React, { useState } from 'react';
    import { useAppStore } from '../store/appStore'; // Adjust path

    function APIKeyModal({ isOpen, onClose }: { isOpen: boolean; onClose: () => void }) {
      const storedApiKey = useAppStore((state) => state.apiKey);
      const setApiKey = useAppStore((state) => state.setApiKey);

      // Local state for the input field within the modal
      const [localKey, setLocalKey] = useState(storedApiKey || '');

      const handleSave = () => {
        setApiKey(localKey); // Update global state
        // Persist to localStorage here if needed
        localStorage.setItem('openai_api_key', localKey);
        onClose();
      };

       // Effect to sync local input if global key changes externally (optional)
       useEffect(() => {
           setLocalKey(storedApiKey || '');
       }, [storedApiKey]);


      if (!isOpen) return null;

      return (
        // Modal JSX
        <div>
          <input type="password" value={localKey} onChange={(e) => setLocalKey(e.target.value)} />
          <button onClick={handleSave}>Save Key</button>
          <button onClick={onClose}>Cancel</button>
        </div>
      );
    }
    ```

**C. Address Generator Integration**

*   The generator (`nodeGenerator` logic) should remain asynchronous.
*   It should read necessary state using `useAppStore.getState()` before starting async operations (API calls).
*   It should call actions obtained via `useAppStore.getState().actionName` to update the store with results (e.g., `updateNodeAnswerChunk`, `addNode`, `setIsGenerating`).
*   Trigger the generator from a `useEffect` in `GraphPage.tsx` based on relevant state changes (e.g., `playing` status, changes in the tree structure that require generation).

**D. Cleanup**

*   Remove the old `qaTreeRef` and `setResultTree(structuredClone(...))` pattern entirely from `GraphPage.tsx`.
*   Remove the `FocusedContext` provider and consumer.
*   Delete `FocusedContext.tsx`.

**3. Documentation, Comments, and TODOs**

*   **Documentation:** While creating `appStore.ts`, add JSDoc comments explaining each state slice and action, as recommended in the rules.
*   **Inline Comments:** As you refactor components (`GraphPage.tsx`, `Flow.tsx`, etc.), add comments explaining:
    *   How components select data from the store (`useAppStore(selector)`).
    *   Why `useShallow` is used.
    *   The purpose of effects that interact with the store or trigger asynchronous operations like the generator.
    *   The flow of data and actions between components and the store.
*   **TODOs:** During the refactor, if you encounter code that seems unused *after* the state logic is moved (e.g., old state update helper functions, potentially parts of `util/`), mark it with `// TODO: Investigate removal after Zustand refactor.`

This plan provides a structured approach to implementing Zustand, addressing the core state management complexity while adhering to the project's defined rules. Remember to test thoroughly after each major step.

---

_**User**_

Here is analysis on the zustand implementation plan.

```report.md
Okay, let's evaluate the Zustand implementation plan based on the codebase, the identified issues, and the previously established rules and guidelines.

Overall, the plan is well-structured, targets the correct areas for refactoring, and incorporates the recommended Zustand practices (`immer`, `devtools`, selectors, `useShallow`). It directly addresses the core complexity of the previous state management approach. However, there are several omissions, potential errors, and areas needing clarification:

**Evaluation of the Plan:**

1.  **Identifying Current State Management Locations:**
    *   **Accurate:** The plan correctly identifies `GraphPage.tsx` as the main hub of complex state and accurately lists other components involved (`Flow.tsx`, `InteractiveNode.tsx`, modals, `StartPage.tsx`, `FocusedContext.tsx`).
    *   **Insightful:** It correctly points out the `ref`+`clone` pattern, the need to replace `FocusedContext`, and the role of modals/API key state.

2.  **Zustand Implementation Plan:**

    *   **A. Define the Store (`src/store/appStore.ts`)**
        *   **Structure & Middlewares:** Correctly uses `create<AppState>()(devtools(immer(...)))`, following guidelines. Store location (`src/store`) is appropriate.
        *   **State Interface (`AppState`):** Generally comprehensive, includes core state (`qaTree`, `playing`, `focusedId`, `apiKey`, `model`, `persona`) and relevant actions. Adding `isGenerating` is a good status indicator.
        *   **Initial State:** Looks reasonable, but:
            *   **OMISSION:** The source/definition of `initialTree` is unclear. How is the store initialized based on the `seedQuery` from `GraphPage` props? The plan needs an action like `initializeTree(seedQuery: string)` or similar logic to set up the very first node (`q-0`).
            *   **OMISSION:** Loading `apiKey` from `localStorage` is mentioned as a possibility but not implemented in the initial state or `setApiKey`. A clear strategy for initial loading is needed.
        *   **Actions (`immer`):**
            *   Simple setters (`setPlaying`, etc.): Correct.
            *   `addNode`, `updateNode`, `updateNodeAnswerChunk`: Correctly use Immer draft state for mutations. The `addNode` logic correctly handles adding to the parent's `children` array immutably within the draft.
            *   **`deleteNode`:**
                *   **ERROR/OMISSION:** This implementation is **not fully recursive** as implied by the original codebase's delete confirmation logic. It only deletes the node itself and potentially its *direct* children referenced in `nodeToDelete.children`. It doesn't traverse the entire branch downwards. The comment acknowledges the complexity but doesn't provide the full solution. This needs to be corrected to match the expected behavior (likely by gathering all descendant IDs *before* calling `set`).
            *   **OMISSION:** No explicit state or actions for handling/displaying errors (e.g., from API calls, generator failures) are defined in the store interface or implementation.

    *   **B. Refactor Components to Use the Store:**
        *   **General Approach:** Correctly advocates removing old state hooks and using `useAppStore` with selectors/`useShallow`.
        *   **`GraphPage.tsx` Example:**
            *   Demonstrates selecting state with `useShallow`: Correct.
            *   Shows getting actions: Correct.
            *   **Generator `useEffect`:** Correctly identifies the need to use `getState()` within async logic to avoid stale closures. This is a critical point. The dependencies (`[playing]`) might be insufficient; the trigger logic needs careful consideration.
            *   **Helper Functions (`reactFlowNodesFromQaTree`, `reactFlowEdgesFromQaTree`):** These are essential but only sketched.
                *   **POTENTIAL ERROR:** The `reactFlowEdgesFromQaTree` example generates edges with `source: node.nodeID`. Based on the original `convertTreeToFlow`, edges often need to originate from the *answer node* (`a-${node.nodeID}`) if it exists, when linking to the next question. This helper needs to replicate the source/target logic from `convertTreeToFlow` accurately.
                *   The `reactFlowNodesFromQaTree` needs to ensure *all* necessary data for `InteractiveNode` is passed in the `data` prop, including `nodeType`, `fileInfo`, `url`, `isLoading`, etc. The example is too simplistic (`{ label: node.question, answer: node.answer }`).
        *   **`InteractiveNode.tsx` Example:** Correctly shows selecting specific state (`isFocused`) and getting/calling actions. Good point about avoiding selecting the whole tree.
        *   **`APIKeyModal.tsx` Example:**
            *   Correctly uses store state/actions.
            *   Uses local state for input: Good pattern.
            *   **CONSISTENCY ISSUE/OMISSION:** Places `localStorage.setItem` in the component. Persistence logic should ideally be centralized, possibly within the `setApiKey` action in the store itself, for consistency. The plan should recommend one approach.
            *   **OMISSION:** The original modal had validation logic (pinging OpenAI). This is missing in the refactor example and needs to be reintegrated, likely triggered *before* calling `setApiKey`.

    *   **C. Address Generator Integration:**
        *   Correctly reinforces using `getState()` and calling actions from the async generator logic.

    *   **D. Cleanup:**
        *   Lists the correct items to remove.

3.  **Documentation, Comments, and TODOs:**
    *   Good emphasis on adding documentation aligned with the rules.

**Summary of Omissions and Errors in the Plan:**

1.  **`deleteNode` Implementation:** The planned `deleteNode` action is **not recursive** and won't delete entire branches as expected. It needs to be rewritten to gather all descendant IDs first.
2.  **Store Initialization:** The plan lacks a clear mechanism to initialize the `qaTree` in the store based on the `seedQuery` provided via props to `GraphPage`. An `initializeTree` action is needed.
3.  **API Key Persistence:** The strategy for *saving* the API key to `localStorage` is inconsistent (shown in the component, but better suited for the store action). The strategy for *loading* the initial key is missing.
4.  **Error Handling State:** The store definition lacks dedicated state slices or actions for managing and displaying application-level errors (e.g., API failures).
5.  **Generator Trigger Logic:** The dependencies for the generator's `useEffect` need careful definition.
6.  **`reactFlow...` Helper Logic:** The example logic for converting `qaTree` to React Flow nodes/edges is incomplete and potentially incorrect regarding edge sources (question vs. answer nodes) and node data payload. It must accurately reflect the needs of `Flow.tsx` and `InteractiveNode.tsx`.
7.  **API Key Validation:** The plan omits the API key validation logic present in the original `APIKeyModal.tsx`.
8.  **"First Answer Node" Issue:** The plan doesn't directly address the original bug report about `a-0` rendering. While the refactor *might* help indirectly by ensuring reactive data flow, a specific check might still be required in `InteractiveNode` or the layout process.

**Conclusion:**

The plan provides a solid foundation for migrating WhyBot to Zustand, correctly identifying the core problems and leveraging Zustand's features effectively (especially `immer`). However, it requires refinement to address the omissions and errors listed above, particularly regarding `deleteNode` recursion, store initialization, API key handling consistency, error state management, and the precise implementation details of the React Flow data conversion helpers and API key validation. Addressing these points will make the transition smoother and result in a more robust and maintainable application.
```

Using the report, update the implementation plan in the file @zustand_update.md 

---

_**Assistant**_

Okay, I will update the implementation plan in `zustand_update.md` to incorporate the feedback from the report.

```markdown:zustand_update.md
**1. Identifying Current State Management Locations**

Based on the file list and common React patterns, state management is likely concentrated in these areas:

*   **`GraphPage.tsx`**: This is explicitly mentioned as the primary location for complex state (`qaTree`, generator logic, node/edge states, focus, playing status) using the `useRef` + `structuredClone` + `useState` pattern. This will be the main target for refactoring.
*   **`Flow.tsx`**: Likely manages React Flow specific state (nodes, edges, viewport), potentially interacting with the global state from `GraphPage.tsx`. We'll need to see how it receives and updates data like nodes/edges.
*   **`InteractiveNode.tsx` / `FadeoutTextNode.tsx`**: These custom nodes might have internal state, but more importantly, they will need to *read* global state (like node data from `qaTree`) and potentially trigger global actions (like focusing or updating node content).
*   **`APIKeyModal.tsx`**: Manages the API key state, likely using `useState`. This seems like a good candidate for global state, including its validation logic.
*   **`AddNodeModal.tsx`**: Manages form state for adding a new node and needs to trigger an action to add the node to the global `qaTree`.
*   **`StartPage.tsx`**: May manage state related to initial setup or loading, potentially including model/persona selection.
*   **`App.tsx`**: Might hold top-level state or context providers, although routing seems to be its main job.
*   **`FocusedContext.tsx`**: Currently uses React Context for focus management. This state (`focusedId`) should be migrated to the Zustand store.

Other components likely use `useState` for local UI state, which is generally fine to leave as is unless it represents shared application state.

**2. Zustand Implementation Plan**

This plan follows the guidelines in `state-management.mdc`.

**Goal:** Consolidate shared application state into a single Zustand store (`useAppStore`) using `immer` for immutable updates and `devtools` for debugging, replacing the `useRef`/`useState` combination in `GraphPage.tsx` and other scattered state logic.

**Steps & Example Snippets:**

**A. Define the Store (`src/store/appStore.ts`)**

*   Create a new directory `src/store` (if it doesn't exist per guidelines).
*   Create `src/store/appStore.ts`.
*   Define the state interface and the store using `create`, `immer`, and `devtools`.

```typescript
// src/store/appStore.ts
import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { devtools, persist } from 'zustand/middleware'; // Added persist
import { QATree, QATreeNode, Persona } from '../types'; // Adjust path as needed
import { availableModels } from '../models'; // Adjust path as needed
// Removed initialTree import - initialization handled differently

interface AppState {
  // Core State
  qaTree: QATree | null; // Initialized via action
  playing: boolean;
  focusedId: string | null;
  apiKey: string | null;
  model: string;
  persona: Persona | null;

  // Status/Error State
  isGenerating: boolean;
  error: string | null; // For displaying application-level errors

  // Actions
  initializeTree: (seedQuery: string, initialPersona?: Persona | null) => void; // New action for initialization
  setPlaying: (isPlaying: boolean) => void;
  setFocusedId: (id: string | null) => void;
  setApiKey: (key: string | null) => void; // Will handle persistence
  setModel: (model: string) => void;
  setPersona: (persona: Persona | null) => void;
  setIsGenerating: (generating: boolean) => void;
  

---



---

