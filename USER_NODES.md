# USER_NODES.md

Below is a detailed outline of the changes needed to support new user-interactive node types in the Q&A tree. Instead of providing code snippets, detailed JSDoc comments are provided for the new components and functions that describe their purpose, behavior, and usage.

## 1. Detailed JSDoc Comments

```typescript
/**
 * @fileoverview Defines the enhanced QATreeNode interface and related types
 *               to support new user-interactive node types.
 */

/**
 * Represents the different types of nodes available in the Q&A tree.
 * - 'llm-question': A question generated by the LLM.
 * - 'llm-answer': An answer generated by the LLM.
 * - 'user-question': A question node manually entered or edited by the user.
 * - 'user-file': A node containing content extracted from a user-uploaded file.
 * - 'user-webpage': A node containing content extracted from a user-provided URL.
 */
type NodeType = 'llm-question' | 'llm-answer' | 'user-question' | 'user-file' | 'user-webpage';

/**
 * Represents metadata for a file uploaded by the user.
 */
interface UserFileInfo {
  /** @property {string} name - The original name of the uploaded file. */
  name: string;
  /** @property {string} type - The MIME type of the uploaded file. */
  type: string;
  /** @property {number} size - The size of the uploaded file in bytes. */
  size: number;
}

/**
 * @interface QATreeNode
 * @description Extends the existing QATreeNode to include type information and
 *              fields specific to user-interactive nodes.
 *
 * @property {NodeType} nodeType - Specifies the type of the node.
 * @property {string} question - The primary text content. For 'llm-question' and 'user-question',
 *                               it's the question text. For other types, it might be a title or summary.
 * @property {string} [parent] - The ID of the parent node in the tree (if any).
 * @property {string} answer - The secondary text content. For 'llm-answer', it's the LLM response.
 *                             For 'user-file', it's the extracted file content (Markdown).
 *                             For 'user-webpage', it's the extracted web content (Markdown).
 *                             For question types, it might be empty or unused initially.
 * @property {string[]} [children] - An array of IDs of child nodes.
 * @property {boolean} [startedProcessing] - Flag indicating if LLM processing (answer/question generation)
 *                                           has begun for this node or its children.
 * @property {UserFileInfo} [fileInfo] - Metadata about the uploaded file (only for 'user-file' type).
 * @property {string} [url] - The URL provided by the user (only for 'user-webpage' type).
 * @property {boolean} [isLoading] - Flag to indicate if the node is currently processing
 *                                   (e.g., uploading file, fetching URL). Used for UI feedback.
 * @property {string} [errorMessage] - Stores any error message related to node processing
 *                                     (e.g., file read error, URL fetch error).
 */
export interface QATreeNode {
  nodeType: NodeType;
  question: string;
  parent?: string;
  answer: string; // Re-purposed for file/web content
  children?: string[];
  startedProcessing?: boolean;
  fileInfo?: UserFileInfo;
  url?: string;
  isLoading?: boolean;
  errorMessage?: string;
}

// --- JSDoc for New/Modified Functions/Components ---

/**
 * @function InteractiveNode
 * @description A React Flow custom node component responsible for rendering all
 *              node types ('llm-question', 'llm-answer', 'user-question',
 *              'user-file', 'user-webpage'). It dynamically displays the appropriate
 *              UI elements (text display, input fields, file dropzone, URL input, buttons)
 *              based on the `nodeType` and manages internal state for user interactions.
 *
 * @param {object} props - Component props.
 * @param {object} props.data - Data associated with the node, conforming to the
 *                              extended QATreeNode structure. Must include `nodeType`,
 *                              `nodeID`, `setNodeData` (callback to update QATree),
 *                              and other relevant fields based on `nodeType`.
 * @param {string} props.data.nodeID - The unique identifier for this node instance (e.g., 'q-0', 'uf-123').
 * @param {NodeType} props.data.nodeType - The type of the node determining its rendering and behavior.
 * @param {string} props.data.text - The primary text content (question or title).
 * @param {string} [props.data.answerText] - The secondary text content (answer or extracted content).
 * @param {boolean} [props.data.isLoading] - Indicates if the node is in a loading state.
 * @param {string} [props.data.errorMessage] - Error message to display, if any.
 * @param {UserFileInfo} [props.data.fileInfo] - File metadata for 'user-file' nodes.
 * @param {string} [props.data.url] - URL for 'user-webpage' nodes.
 * @param {(nodeId: string, dataChanges: Partial<QATreeNode>) => void} props.data.setNodeData - Callback function
 *      to update the central QATree state in GraphPage when node data changes due to user interaction
 *      (e.g., typing in input, selecting file, submitting URL).
 * @param {(nodeId: string) => void} [props.data.onGenerateAnswer] - Callback to trigger LLM answer generation
 *      (used by 'user-question' and potentially downstream from file/web nodes).
 * @param {boolean} [props.data.isAnswering] - Flag indicating if LLM answer generation is in progress.
 * @param {(parentId: string, newNodeType: NodeType) => void} props.data.requestAddUserNode - Callback to request
 *      the creation of a new user node as a child of the current node.
 * @param {React.Dispatch<React.SetStateAction<NodeDims>>} props.data.setNodeDims - Function to update node dimensions.
 * @param {boolean} props.selected - Passed by React Flow, indicates if the node is selected.
 * @param {boolean} props.dragging - Passed by React Flow, indicates if the node is being dragged.
 *
 * @returns {React.ReactElement} The rendered React Flow node component.
 */

/**
 * @function convertTreeToFlow
 * @description (Modified) Converts the QATree data structure into arrays of nodes and edges
 *              compatible with React Flow. This version handles the different `nodeType`s,
 *              mapping them to the appropriate React Flow node type (e.g., 'interactiveNode')
 *              and passing necessary data and callbacks.
 *
 * @param {QATree} tree - The current state of the Q&A tree.
 * @param {React.Dispatch<React.SetStateAction<NodeDims>>} setNodeDims - Function to update node dimensions.
 * @param {(edgeId: string) => void} requestDeleteBranch - Callback to initiate branch deletion.
 * @param {boolean} playing - Flag indicating if the generation process is active (for edge animation).
 * @param {(nodeId: string) => Promise<void>} generateAnswerForNode - Callback to manually trigger LLM answer.
 * @param {(parentId: string, newNodeType: NodeType) => void} requestAddUserNode - Callback to request adding a new user node.
 * @param {(nodeId: string, dataChanges: Partial<QATreeNode>) => void} setNodeData - Callback to update node data in the main tree state.
 * @param {Set<string>} answeringNodes - Set of node IDs currently generating an LLM answer.
 *
 * @returns {{nodes: Node[], edges: Edge[]}} An object containing arrays of React Flow nodes and edges.
 */

/**
 * @function getPromptForAnswer
 * @description (Modified) Generates the prompt string to be sent to the LLM for generating an answer.
 *              This version traces the node's ancestry. If an ancestor is a 'user-file' or
 *              'user-webpage' node, its extracted content (`answer` field) is prepended
 *              to the prompt context, clearly indicating its source (e.g., "Context from file [filename]: ...").
 *              Handles potential token limit constraints by summarizing or truncating context if necessary.
 *
 * @param {QATreeNode} node - The node for which the answer is being requested. This is typically
 *                            an 'llm-question' or 'user-question' node.
 * @param {QATree} tree - The entire Q&A tree, used to access parent nodes and their content.
 * @returns {string} The generated prompt string for the LLM.
 */

/**
 * @function handleFileUpload
 * @description Handles the selection or dropping of a file for a 'user-file' node.
 *              Reads the file content as text, validates it (e.g., basic text check, size limit),
 *              updates the corresponding QATreeNode with file info and content (via `setNodeData`),
 *              and handles potential read errors.
 *
 * @param {File} file - The file object selected or dropped by the user.
 * @param {string} nodeId - The ID of the 'user-file' node being updated.
 * @param {(nodeId: string, dataChanges: Partial<QATreeNode>) => void} setNodeData - Callback to update the QATree state.
 * @returns {Promise<void>} A promise that resolves when file processing is complete or rejects on error.
 * @throws {Error} If the file is not a text-based file or exceeds size limits.
 * @throws {Error} If there's an error reading the file content.
 */

/**
 * @function fetchWebpageContent
 * @description Client-side function to initiate the fetching of web page content.
 *              It takes a URL and node ID, sets the node to a loading state,
 *              calls the backend API endpoint (`/api/fetch-webpage`), and updates
 *              the node with the returned Markdown content or an error message via `setNodeData`.
 *
 * @param {string} url - The URL entered by the user.
 * @param {string} nodeId - The ID of the 'user-webpage' node being updated.
 * @param {(nodeId: string, dataChanges: Partial<QATreeNode>) => void} setNodeData - Callback to update the QATree state.
 * @returns {Promise<void>} A promise that resolves when the fetch and update are complete or rejects on error.
 */


// --- JSDoc for New Backend Components ---

/**
 * @module server/routes/webpage
 * @description Defines the backend API route for fetching and processing web page content.
 */

/**
 * @function fetchWebpageHandler
 * @description The handler function for the `/api/fetch-webpage` endpoint.
 *              Receives a URL in the request body/query parameters.
 *              Uses Puppeteer to launch a headless browser, navigate to the URL,
 *              and retrieve the page's HTML content.
 *              Uses Mozilla's Readability library to extract the main article content
 *              from the HTML and convert it into Markdown format.
 *              Includes error handling for invalid URLs, network issues, timeouts,
 *              content extraction failures, and resource management (closing the browser).
 *              Implements security measures like SSRF prevention and limiting resource usage.
 *
 * @param {Request} req - The Express request object (or equivalent based on backend framework).
 *                        Expected to contain the target URL (e.g., `req.query.url`).
 * @param {Response} res - The Express response object (or equivalent).
 * @returns {Promise<void>} Sends a JSON response containing `{ markdownContent: string }` on success,
 *                          or an error status code and message `{ error: string }` on failure.
 * @throws {Error} Logs internal server errors during processing.
 */

/**
 * @package puppeteer
 * @description Node.js library providing a high-level API to control Chrome/Chromium
 *              over the DevTools Protocol. Used for headless browsing to fetch dynamic web content.
 *              (Dependency to be added to backend `package.json`).
 */

/**
 * @package @mozilla/readability
 * @description Library to extract the primary readable content of a webpage,
 *              removing clutter like ads, menus, etc. Used to clean HTML before Markdown conversion.
 *              (Dependency to be added to backend `package.json`).
 *              *Note: Requires a separate library or custom logic for Markdown conversion.*
 */

/**
 * @package TurndownService (or similar Markdown converter)
 * @description Library used server-side to convert the cleaned HTML (from Readability)
 *              into Markdown format.
 *              (Dependency to be added to backend `package.json`).
 */
```

## 2. Implementation Outline

1.  **Data Model Enhancement (`GraphPage.tsx`, potentially new `types.ts`):**
    *   Introduce the `NodeType` enum/type.
    *   Modify the `QATreeNode` interface to include `nodeType`, `isLoading`, `errorMessage`, and optional fields `fileInfo`, `url`. The existing `answer` field will be repurposed to store extracted content for `user-file` and `user-webpage` nodes.
    *   Update the initial state in `GraphPage.tsx` to use the new structure (e.g., the seed node will have `nodeType: 'llm-question'`).

2.  **Create Universal Node Component (`InteractiveNode.tsx`):**
    *   Develop a new React Flow custom node component (`InteractiveNode`).
    *   It will receive node data (`props.data`) conforming to the enhanced `QATreeNode`.
    *   Use conditional rendering based on `props.data.nodeType` to display:
        *   `llm-question`/`llm-answer`: Similar display to `FadeoutTextNode` (potentially reusing its core rendering logic), showing `question` or `answer`.
        *   `user-question`: Display an editable `TextareaAutosize` for the `question` field. Include an "Answer" button, disabled until the question meets the minimum length (e.g., 20 chars). Connect button to `props.data.onGenerateAnswer`.
        *   `user-file`: Display a file input (`<input type="file">`) and/or a drag-and-drop zone. Show file info (`props.data.fileInfo`) and the extracted `answer` (Markdown content) once loaded. Include loading/error states. Display a button like "Add Follow-up Question" connected to `props.data.requestAddUserNode`.
        *   `user-webpage`: Display a URL input field and a "Get WWW" button. Show the extracted `answer` (Markdown content) once fetched. Include loading/error states. Display a button like "Add Follow-up Question" connected to `props.data.requestAddUserNode`.
    *   Implement internal state management within `InteractiveNode` for input values before they are committed to the main `QATree` via `props.data.setNodeData`.
    *   Utilize `props.data.setNodeDims` for proper layout adjustments based on content changes.

3.  **React Flow Integration (`Flow.tsx`, `GraphPage.tsx`):**
    *   Replace `FadeoutTextNode` with `InteractiveNode` in the `nodeTypes` definition in `Flow.tsx`.
    *   Modify `convertTreeToFlow` in `GraphPage.tsx`:
        *   Map all `QATreeNode` entries to `type: 'interactiveNode'`.
        *   Pass all necessary data fields from the enhanced `QATreeNode` to `props.data` for `InteractiveNode`.
        *   Pass down required callbacks: `setNodeData`, `generateAnswerForNode`, `requestAddUserNode`.

4.  **User Node Creation Logic (`GraphPage.tsx`):**
    *   Implement the `requestAddUserNode` callback function in `GraphPage`. This function will:
        *   Receive the `parentId` and the `newNodeType` ('user-question', 'user-file', 'user-webpage').
        *   Generate a new unique ID for the user node.
        *   Create a new `QATreeNode` object with the specified `nodeType`, `parent` ID, and default values (e.g., empty question/answer, `isLoading: false`).
        *   Update the `qaTreeRef.current` and `resultTree` state by adding the new node and updating the parent's `children` array.
    *   Modify the UI where node creation is triggered (e.g., potentially add buttons to existing nodes or implement a dedicated panel) to call `requestAddUserNode`. *Initial simple approach: Modify `InteractiveNode` for 'llm-question'/'llm-answer' to show "Add User Node" buttons.*

5.  **File Handling (Client-Side - `InteractiveNode.tsx`, new `src/util/fileUtils.ts`):**
    *   Implement `handleFileUpload` utility function (or integrate logic directly in `InteractiveNode`).
    *   Use `FileReader.readAsText()` to get file content.
    *   Perform basic validation (e.g., check if `file.type` starts with `text/`, or attempt to parse first few KB as text). Enforce size limits.
    *   On successful read, call `setNodeData` to update the `user-file` node in `QATree` with `fileInfo` and the content stored in the `answer` field. Set `isLoading: false`.
    *   On error, call `setNodeData` to set `isLoading: false` and populate `errorMessage`.
    *   Update `InteractiveNode` for `user-file` to use this logic and display progress/errors.

6.  **Web Page Handling (Frontend: `InteractiveNode.tsx`, new `src/util/urlUtils.ts`; Backend: new route):**
    *   **Frontend (`InteractiveNode.tsx`, `urlUtils.ts`):**
        *   Add URL input and "Get WWW" button to `InteractiveNode` for `user-webpage`.
        *   Implement basic URL validation (`urlUtils.ts`).
        *   Implement `fetchWebpageContent` function:
            *   On button click, validate URL. If valid, call `setNodeData` to set `isLoading: true`, clear previous errors.
            *   Make a `fetch` request to the new backend endpoint (e.g., `/api/fetch-webpage?url=ENCODED_URL`).
            *   On success (HTTP 200 and valid JSON response), call `setNodeData` with the Markdown content stored in `answer`, `isLoading: false`.
            *   On failure (network error, non-200 status, invalid JSON), call `setNodeData` with `isLoading: false` and an appropriate `errorMessage`.
    *   **Backend (New Files/Modules):**
        *   Set up a new API route (e.g., `/api/fetch-webpage`).
        *   Install dependencies: `puppeteer`, `@mozilla/readability`, `turndown` (or similar).
        *   Implement the `fetchWebpageHandler`:
            *   Get URL from request. Sanitize/validate it.
            *   Launch Puppeteer, navigate, get HTML. Handle timeouts/errors.
            *   Use Readability to parse HTML.
            *   Use Turndown to convert cleaned HTML to Markdown.
            *   Close Puppeteer browser instance.
            *   Send Markdown back in JSON response or send error response.
        *   Deploy backend changes. Ensure environment has necessary dependencies for Puppeteer (e.g., specific OS libraries if deploying to Linux).

7.  **LLM Prompt Modification (`GraphPage.tsx`, `personas.ts`):**
    *   Modify the prompt generation logic (likely within `GraphPage.tsx` or potentially refactored from `personas.ts` if logic is complex).
    *   Before calling `openai`, trace the current node's lineage using `parent` IDs up to the root.
    *   Identify any `user-file` or `user-webpage` ancestors.
    *   Prepend their `answer` content (clearly labeled, e.g., `"[Context from file 'report.txt']:\n{content}\n\n[Context from URL '...']:\n{content}\n\nOriginal Prompt:\n..."`) to the prompt being sent to the LLM.
    *   Implement context truncation/summarization if the combined context exceeds token limits.

8.  **Enforce Mandatory Downstream Nodes (`InteractiveNode.tsx`, `GraphPage.tsx`):**
    *   In `InteractiveNode` for `user-file` and `user-webpage` types:
        *   Once content is loaded (`isLoading` is false and `answer` has content), *do not* show the standard LLM "Answer" button (if applicable).
        *   *Only* show buttons that trigger `requestAddUserNode` for allowed downstream types (e.g., 'user-question', maybe 'user-file' for webpage node).
    *   Optionally, add validation in `GraphPage` before allowing LLM calls downstream from file/web nodes to ensure the required intermediate node exists, though UI enforcement is preferred.

9.  **Styling and UI/UX:**
    *   Style the new input fields, buttons, file dropzone, loading indicators, and error messages within `InteractiveNode` to match the application's aesthetic.
    *   Ensure clear visual distinction between different node types if desired (e.g., icons, border colors - though current design uses border colors already).
    *   Provide clear user feedback for loading states and errors.

10. **Testing:**
    *   Thoroughly test each user node type individually (creation, interaction, data saving).
    *   Test file upload with various text file types and sizes (including edge cases like empty files, very large files, non-text files).
    *   Test web page fetching with various URLs (simple articles, complex dynamic pages, error pages, invalid URLs).
    *   Test the interaction between user nodes and LLM nodes (prompt context injection, downstream generation).
    *   Test the mandatory downstream node enforcement.
    *   Test node deletion and its effect on the tree structure.
    *   Test layout adjustments with varying content lengths in user nodes.

## 3. Modification List

*   **`app/src/GraphPage.tsx`:**
    *   Update `QATreeNode` interface definition (or import from a new types file).
    *   Modify `convertTreeToFlow` to map to `'interactiveNode'`, pass new data/callbacks.
    *   Update initial state creation (`useState<QATree>`) for the root node's `nodeType`.
    *   Implement the `requestAddUserNode` function logic.
    *   Implement the `setNodeData` function logic to update `qaTreeRef.current` and `resultTree` state.
    *   Modify the LLM prompt generation logic (where `openai` is called) to include context from ancestor `user-file`/`user-webpage` nodes.
    *   Potentially adjust `nodeGenerator` or manual generation logic (`generateAnswerForNode`) if user nodes can directly trigger LLM calls in specific ways.
    *   Update state management for `answeringNodes` or add new state for `loadingNodes`.
*   **`app/src/Flow.tsx`:**
    *   Update `nodeTypes` to replace `fadeText` with `interactiveNode` pointing to the new component.
*   **`app/src/FadeoutTextNode.tsx`:**
    *   This file will likely be **removed** or its core text rendering/fading logic might be extracted and reused within `InteractiveNode.tsx`.
*   **`app/src/fadeout-text.css`:**
    *   May be **removed** or adapted if the fading effect is incorporated into the new node's CSS.
*   **`server/...` (Backend - specific files depend on existing structure):**
    *   Add a new route file (e.g., `server/routes/webpage.ts`) for the `/api/fetch-webpage` endpoint.
    *   Register the new route in the main server setup file (e.g., `server/index.ts` or `server/app.ts`).
    *   Update backend `package.json` to include `puppeteer`, `@mozilla/readability`, `turndown`.
    *   Update deployment configurations/scripts if necessary for backend changes and new dependencies (especially Puppeteer's OS requirements).

## 4. New File List

*   **`app/src/InteractiveNode.tsx`:** The new universal React Flow custom node component for rendering all node types and handling user interactions.
*   **`app/src/InteractiveNode.css`:** (Optional) CSS specific to the styling of the `InteractiveNode` component and its internal elements (inputs, buttons, dropzone, etc.).
*   **`app/src/types.ts`:** (Optional) A dedicated file to hold shared TypeScript interfaces and types, including the enhanced `QATreeNode`, `NodeType`, `UserFileInfo`, etc., to improve organization.
*   **`app/src/util/fileUtils.ts`:** (Optional) Utility functions for client-side file handling (reading, validation).
*   **`app/src/util/urlUtils.ts`:** (Optional) Utility functions for client-side URL validation.
*   **`server/routes/webpage.ts`:** (Backend) Contains the Express route handler (or equivalent) for the `/api/fetch-webpage` endpoint, using Puppeteer and Readability.
*   **`USER_NODES.md`:** (This file) The markdown report detailing the implementation plan.

**New Backend NPM Modules:**

*   `puppeteer`: For headless browser interaction.
*   `@mozilla/readability`: For extracting article content from HTML.
*   `turndown`: (Or a similar library) For converting HTML to Markdown.